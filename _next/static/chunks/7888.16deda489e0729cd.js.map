{"version":3,"file":"static/chunks/7888.16deda489e0729cd.js","mappings":"uaAAmE,UAA0F,IAAtE,CAAqE,CAAC,KAAiB,aAAie,kBAAkB,IAAhd,EAAgd,MAAW,gBAAiB,gBAAgB,qBAAsB,kBAAkB,2HAAiO,gBAAgB,6BAA6B,sBAAsB,6DAA6D,YAAY,IAAI,KAAK,oBAAoB,mBAAmB,SAAS,gBAAgB,qIAAqI,gBAAgB,qBAAqB,gBAAgB,qBAAqB,cAAc,sCAAsC,cAAc,qCAAqC,gBAAgB,sEAAsE,gBAAgB,sEAAsE,cAAc,OAAO,mEAAmE,sBAAsB,gBAAgB,SAAS,mCAAmC,8BAA+B,CAAroD,uBAAuB,KAAK,IAAI,EAAE,YAAY,8KAA8K,aAAa,mBAAmB,mCAAmC,IAAI,EAAE,qBAAqB,aAAY,IAAK,KAAK,YAAY,KAAK,gEAA+D,CAAquC,OAAruC,EAAquC,KAAruC,SAAquC,GAAruC,GAAquC,iBAA8B,kCAAkC,+BAA+B,gCAAgC,qBAAqB,oBAAoB,2BAA2B,EAAE,EAAE,YAAY,oBAAoB,KAAK,oCAAoC,2DAA2D,UAAU,SAAS,kCAAkC,gBAAgB,oBAAoB,aAAa,EAAE,EAAE,YAAY,oBAAoB,KAAK,8CAA8C,WAAW,2BAA2B,WAAW,UAAU,SAAS,8BAA8B,6BAA6B,8BAA8B,YAAY,WAAW,sBAAsB,YAAY,4CAA4C,yFAAyF,KAAK,8BAA8B,gBAAgB,gBAAgB,+CAA+C,iBAAiB,YAAY,gCAAgC,kDAAkD,8BAA8B,4BAA4B,kCAAkC,kBAAkB,qDAAqD,YAAY,EAAE,yDAAyD,eAApxE,OAAkB,0BAA0B,YAAY,WAAW,0BAA0B,WAAurE,gBAAwB,yEAAyE,qGAAqG,YAAY,gCAAgC,SAAS,uCAAuC,qBAAqB,uCAAuC,qBAAqB,+BAA+B,iBAAiB,kCAAkC,wBAAwB,gCAAgC,aAAa,EAAE,wEAAwE,SAAS,sCAAsC,iCAAiC,oDAAoD,sGAAsG,iDAAiD,4BAA4B,YAAY,KAAK,MAAM,wBAAwB,4BAA4B,YAAY,KAAK,MAAM,wBAAwB,yCAAyC,0BAA0B,8CAA8C,KAAK,kCAAkC,EAAE,iCAAiC,oBAAoB,KAAK,mIAA6I,8CAA8C,mBAAmB,OAAQ,EAAS,qCAAqC,qEAAqE,8BAA8B,4CAA4C,sBAAsB,gCAAgC,kCAAkC,kDAAkD,6BAA6B,kFAAkF,iHAAiH,sCAAsC,0FAA0F,+CAA+C,kCAAsC,OAAO,KAAK,gOAAsP,+CAA8C,cAAc,8CAA8C,4DAA4D,8EAA8E,8CAA8C,mBAAmB,kEAAkE,MAAM,KAAK,oBAAoB,2BAA2B,gBAAgB,KAAK,KAAK,mBAAoB,4BAA2B,SAAS,iDAAiD,YAAY,KAAK,cAAc,mCAAmC,8BAA8B,KAAK,gHAAgH,GAAG,oICC7zM,gBACA,GACA,uBACA,uBACA,wBACA,qBACA,0BACA,qBACA,qBACA,OATA,UAUA,OAVA,UAWA,wBACA,wBACA,wBACA,6BACA,UACA,uBACA,EAkBA,mBAA+C,EAC/C,OAAiB,gBASjB,MARA,kBACA,YAEA,QACA,gBAEA,mBACA,aACA,CACA,CAmBA,mBAAoD,EACpD,MACA,uCAEA,qBACA,4CAEA,cACA,2DAEA,sBACA,gDAMA,SAJA,CACA,aACA,aACA,EACA,IACA,CASA,mBAAsD,EACtD,gBACA,cACA,YACA,+DAGA,sCACA,2DAEA,YAAoB,uBAAkC,IACtD,8BACA,0DAGA,CAKA,SAJA,CACA,eACA,aACA,EACA,IACA,CASA,mBAAyD,EACzD,cACA,qEAMA,SAJA,CACA,kBACA,aACA,EACA,IACA,CASA,iBAAiD,EACjD,OAAe,0BAQf,OAPA,MACA,YAEA,QACA,gBAEA,aACA,CACA,CAeA,mBAA2D,EAK3D,SAJA,CACA,oBACA,aACA,EACA,IACA,CAeA,6BACA,WACA,MACA,mCAEA,UACA,CACA,6BACA,WACA,MACA,mCAEA,UACA,CAwBA,cAEA,SADA,IACA,WACA,CAqBA,cACA,4CACA,0EEzPe,SACf,sBAKA,GAJA,YACA,6BACA,eAEA,cACA,6BAAiD,KAAQ,iBAEzD,CAEA,QACA,kBACA,cACA,uBACA,CAEA,MACA,0BAEA,mBACA,kBAQA,OAPA,cAEA,gBACA,eACA,eAGA,CACA,CAEA,OACA,oBAGA,OACA,SAAe,aAAe,KAC9B,OAEA,WACA,aACA,OACA,kBACA,QACA,GACA,CAEA,MACA,CAEA,SACA,SAAe,aAAe,KAC9B,iBACA,OAEA,WACA,eACA,OACA,MAMA,GAJA,6BACA,IACA,QAEA,eAEA,QACA,GACA,CAEA,MACA,CACA,CAEA,gBACA,oBACA,6CE5EA,cACA,MACA,iCAEA,sBACA,oEACA,kCAEA,oBACA,wBAEA,CACA,6EACA,mBAEA,2DACA,iCCfA,mBAAwC,EACxC,MAAqB,EAAQ,GAC7B,EAAqB,CADQ,CACA,GAK7B,GAL6B,IAK7B,cAJa,OAAgB,YAI7B,wBAHa,QAAgB,YAG7B,eAFa,QAAgB,QAE7B,SADa,QAAgB,QAE7B,MAAS,QAAe,CACxB,0CACA,QAEA,gCC+HA,gBACA,sBACA,YACI,gCACJ,YAAoB,qBACpB,wBADiD,KAIjD,CAiBA,gBACA,wGACA,QAAc,IAAU,KAOxB,QANA,0CACA,+CACA,uCACA,mCAEA,EADA,uCACA,sBACgB,IAAW,KAE3B,UADA,wBACA,CACA,GAMA,KANA,EACA,KACA,EACA,EACA,EACA,GAEA,SACA,QACA,CACA,eACA,YACA,iBACA,iBACA,cACA,sBACA,mBACA,IAMA,IANA,EACA,EACA,EACA,EACA,EACA,GAEA,SACA,KAEA,0BACA,QAAsB,sBAAgC,IACtD,IAMA,IANA,EACA,gBACA,EACA,EACA,EACA,GAEA,SAEA,KAEA,SACA,oCACA,CACA,CACA,GACA,CACA,eA/NA,kBACA,YAEA,QADA,mGACA,IAA6B,IAAqB,KAGlD,GADA,IADA,6CACA,+BACA,sBACA,YAA4B,IAAmB,KAC/C,QACA,IAEA,UADA,yBAEA,gBACA,aAEA,OADA,6CACA,GACA,UACA,KACA,aACA,GAMA,KANA,EACA,EACA,EACA,EACA,EACA,GAEA,QACA,KACA,IACA,KACA,kBACA,iBACA,QAAsB,WAAmB,KACzC,GAMA,KANA,EACA,KACA,EACA,EACA,EACA,GAEA,QACA,KACA,qBACA,CACA,sBACA,KACA,eACA,sBACA,QAAsB,WAAmB,KACzC,QAAwB,gBAAmC,KAC3D,IAMA,IANA,EACA,QACA,EACA,EACA,EACA,GAEA,QACA,IACA,CACA,2BACA,kBACA,CACA,mBACA,K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AEA,WACA,WAEA,CAAG,EACH,CACA,sDsC+Be,8CpC9CA,aACf,IAD0B,GAC1B,KACA,CAEA,aACA,YACA,CAEA,aACA,cACA,iBACA,OACA,QACA,CAAG,CADa,IAEhB,YACA,cACA,mBACA,mBACA,WACG,CACH,mBACA,cAEA,EAEA,YAEA,kBACA,cACA,KAEA,OADA,MACA,KACA,CCrCO,IAAI,EAAE,QACF,EAAS,EAAE,EACf,EAAgB,CADD,CACG,CADR,CAEN,EAAQ,CADM,CACR,EAEN,EAFG,GAAK,CAEQ,EAChB,EAAU,EADH,CAAW,GAGlB,CAFY,CAET,EAFI,GAEJ,IACH,EAAI,UACJ,EAAK,WACL,EAAG,SAEP,WAEI,EAAG,SAEH,EAAG,SAEH,EAAI,UACJ,EAAG,SAEP,cACP,kBAA8B,EAAE,YAChC,CAEO,SAAS,EAAI,GACpB,IADoB,GACpB,IAAiB,EAAM,MAAa,EAAM,CAAnB,IAAmB,OAC1C,CC9Be,cCAf,gBACA,6BACA,cAEA,CAEA,OACA,sBACA,eACA,CAAG,CACH,gCAEA,IADA,iCACA,yBACA,CACA,EAEA,GACA,qBACA,UACA,CAAG,CACH,oBACA,gBACA,uBACA,CAAG,CACH,yBAEA,IADA,oCACA,qCACA,CAAG,CACH,yBACA,oBACA,CAAG,CACH,8BAEA,IADA,oCACA,kBACA,CAAG,CACH,sBACA,kBACA,CAAG,CACH,2BAEA,IADA,oCACA,gBACA,CAAG,CACH,iCAEA,IADA,mCACA,gBACA,CACA,EAEA,kBACA,wBAEA,IADA,cACA,sCACA,WACA,CAEA,gBACA,oBAEA,IADA,iBACA,mBACA,cACA,CAEe,WAAS,KACxB,4BACA,eAEA,MAEA,CC/DO,IAGP,EACA,EACA,EACA,EACA,EAPO,EAAkB,IAEzB,CAF8B,CAEhB,IAOP,CAPY,CAOZ,CACP,MAAS,EACT,EADa,QACA,EACb,EADiB,MACN,EACX,EADe,WACf,WACA,UACA,cACA,WACA,CAAG,CACH,sBACA,SACA,UAA+B,EAAG,KAClC,CADkC,GAClC,mCAAiD,CACjD,CAAG,CACH,CAFqD,MAErD,WACA,M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,GACb,EAAU,CADG,CACG,EAAI,iEACpB,MACA,kBACA,kBACA,kBACA,YACA,CAEA,cACA,WACA,CAIA,cACA,WACA,CAEA,cACA,GAAoB,GAAU,IAC9B,UAD4B,CAE5B,CAEA,iBACE,GAAQ,EAAW,GAAK,EAC1B,GAAY,EAAO,EADT,CACkB,CADF,CAE1B,KADmB,GACnB,EADmC,EAEnC,MAAe,EAAG,GAClB,GADkB,EACF,EAAG,GACnB,GADmB,EACH,EAAG,GACnB,GAAO,EAAG,GACV,GADU,GACV,MACA,CAEA,iBACA,GAAY,EACZ,MAAe,EADI,GAAS,GACV,EAClB,EAAmB,EAAG,GAFa,EAGnC,CADsB,CACH,EAAG,GACtB,EAAU,CADY,CACT,GACb,GADa,EACb,OACA,YACA,YACA,EAAU,EAAI,aACd,EAAU,EAAI,GACd,IADc,CACd,KACA,CADuB,GACvB,IACA,QACA,QACA,MACA,kBACA,kBACA,kBACA,YACA,CClHe,YAAS,KAExB,gBACA,4BACA,CAMA,OAJA,4CACA,4CACA,GAEA,CACA,CCRA,iBACA,SAAmB,EAAE,EAAY,EAAG,CAAf,CAAe,CAAa,EAAE,CAAf,CAA2B,EAAG,CAAf,CAAe,GAYlE,CAZkE,QAYlE,MACA,qBACA,cAA4C,EAAE,EAAY,EAAG,CAAf,CAAe,CAAa,EAAE,CAAf,CAA2B,EAAG,CAAf,CAAe,GAE3F,CAEA,eACA,YAEA,OADA,gBACA,CACA,CAEA,iBACA,MAAoB,EAAG,GACvB,EAAoB,CADG,CACA,GACvB,EAAsB,CADC,CACE,GACzB,EAAsB,CADG,CACA,GAEzB,GAFyB,MAEzB,OACA,MAAiB,EAAG,GACpB,EAAY,CADQ,CACL,KACf,CADe,CACH,EAAG,KACf,CADe,CACH,EAAG,GACf,GADe,CACf,MACA,OACM,EAAK,iBACL,EAAI,SAEV,CAcA,OAZA,uBACA,MAAiB,EAAG,GACpB,EAAY,CADQ,CACL,KACf,CADe,CACH,EAAG,KACf,CADe,CACH,EAAG,GACf,GADe,CACf,MACA,OACM,EAAK,iBACL,EAAI,SACV,EAGA,CACA,CApDA,aCmBA,iBACA,EAAU,EAAS,WACjB,GAAyB,GAC3B,MAAe,EAAI,OACnB,IAF2B,EAE3B,gBAA+C,ET9B7B,IS8BmC,CAAO,CAAV,CAClD,CC7Be,CD4BsC,KAAc,GC5BpD,KACf,IAD0B,EAC1B,KAEA,OACA,oBACA,aACA,CAAK,CACL,qBACA,YACA,CAAK,CACL,QAAa,EACb,EADiB,KACjB,WACA,6CACA,CAAK,CACL,kBACA,QAGA,OAFA,KACA,OACA,CACA,CACA,CACA,CErBe,YAAS,KACxB,OZHkB,KYGT,EAAG,YZHM,CYGU,IAAW,EAAG,MAAP,CAAO,GAC1C,CCFA,EDC0D,OCD1D,YACA,SACA,SACA,SACA,KADkB,CAClB,GACA,KADkB,CAClB,IACA,KADkB,CAClB,YACA,CAKe,CANW,QAMX,GAAS,WACxB,IAEA,EACA,EAHA,KACA,KAwBA,GApBA,sBACA,yBACA,sBAKA,GAAQ,GAAU,MAElB,CAFkB,GAClB,cACA,IAAkB,IAAO,8BACzB,YACA,MACA,CAEA,8BACA,gCACA,8BACA,gCACA,CAAG,EAEH,UAMA,IAJA,UACE,GAAI,GACJ,GAAI,GADA,EAGN,aAA+B,IAAO,IACtC,YAOA,IAJA,IACA,EACA,EAFA,SAIA,CAIA,IAFA,QACA,KACA,2BACA,MACA,cACA,GAEA,GADA,aACA,KACA,KACA,mBAAyC,IAAO,mCAEhD,iBAEA,KACA,EAAQ,IACR,KAEA,MADA,UACA,SAAsC,KAAQ,mCAE9C,kBAEA,MAGA,EADA,QACA,EACA,IACA,EAAM,WACN,WACA,EACA,CAEA,SAAS,GAAI,GACb,MADa,CACb,QAKA,IAJA,MAGA,EAFA,IACA,OAEA,OACA,WACA,MACA,GAEA,YACA,MACA,CCpGe,YAAS,KACxB,8BACA,CECA,ODDe,QCCe,CDDN,OA0BxB,EAxBA,OADA,eAyBA,EAzBA,IA0BA,cACA,OAAW,GAAS,OACpB,GA3BA,CACA,uBAGA,IAFA,eACA,sBACA,MACA,aACA,mBACA,GACA,CACA,QACA,CAAK,CACL,wBAGA,IAFA,eACA,sBACA,MACA,aACA,iBACA,KACA,CACA,QACA,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EhB,WACA,CAHyC,GAGrB,GAAY,GAAK,IACjC,GAAY,CADmB,GAAK,CACxB,CAAS,CACzB,CAAG,CACH,CAF6B,OAAb,KAEhB,WACA,KACA,CAAG,CACH,sBACA,OACA,CAAG,CACH,kBACA,OAAkB,GAElB,OADI,GAAS,IADc,CACd,GACb,CACA,CACA,EAEA,EALa,OAKJ,GAAgB,KACvB,GAAY,MAAS,GACrB,GAAM,CAFiB,EAEf,EAAM,GAAM,EAAZ,CAAc,CACxB,CAEA,GAHmB,EAAK,IAGf,GAAW,KAClB,IAAE,EAAO,IAAP,CADgB,CAElB,GAAS,CADE,EACF,CAAK,EAAK,GAAK,GAAK,CAAX,CAAT,CAAyB,CAAb,GAAK,CAC1B,EAD+B,CAC7B,EADkC,GAC1B,CACZ,CADI,KAAQ,IGnCG,GAAS,SACxB,qBACA,IAKA,EACA,EACA,EAPA,OACA,sBACA,EAAqB,KACrB,CAD+B,CAC/B,KACA,KAKA,GACA,QACA,YACA,UACA,wBACA,UACA,cACA,YACA,KACA,KACO,CACP,sBACA,UACA,cACA,YACA,EAAmB,GAAK,GACxB,MAA0B,GAAe,IACzC,QADyC,CACzC,EACA,2BACU,GAAW,aACX,IACV,2BACA,cACA,iBACA,aAEA,yBACA,QACA,CAAO,CACP,kBACA,iBACA,cACA,iBACA,YACA,cACA,CACA,EAEA,gBACA,YACA,+BACA,CAEA,gBACA,aACA,kBACA,CAEA,aACA,UACA,aACA,CAEA,aACA,UACA,WACA,CAEA,gBACA,cACA,aACA,kBACA,CAEA,aACA,cACA,KAGA,aACA,mBACA,YAEA,IAEA,IACA,EACA,EAJA,YACA,aACA,WAQA,GAJA,QACA,UACA,OAEA,GAGA,QAEA,OADA,QACA,aAGA,IAFA,2BACA,cACA,IAAsB,IAAO,8BAC7B,WACA,CACA,MACA,CAIA,4CAEA,qBACA,CAEA,QACA,CACA,CAEA,eACA,iBACA,CAIA,iBACA,yBAAoC,ErCpIlB,KqCoIqC,EAAM,EAAnB,EAAmB,CAAhB,CAC7C,GAD6D,CAC7D,OADoD,CACpD,OAAoC,ErCrIlB,KqCqIqC,EAAM,EAA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,GAAP,CAAO,IvB9BjB,KuB+BR,EAAG,QAAqB,GAAP,CAAO,IvB/BhB,KuBgCR,EAAG,QAAqB,GAAP,CAAO,GAClC,OACA,CAFkC,CACD,QAGjC,OACA,iBACA,CAEA,gBACA,aACA,SACA,iBACA,gBACA,gBACA,gBACA,UAGA,mBACA,IAEA,EACA,EACA,EACA,MACA,MACA,EACA,EARA,IACA,EAAuB,KASvB,CATiC,CASjC,CACA,QACA,UAgDA,WACA,UACA,gBACA,KACA,KACA,OACA,EArDA,QA0DA,WACA,IACA,OACA,iBACA,oBAEA,UACA,cACA,EAjEA,aAuBA,WACA,kBACA,EAxBA,WA0BA,WACA,iBAjBA,QAFA,IAEA,eAA0C,IAAO,IACjD,uDAAmH,IAAO,IAC1H,6BACA,KAA0B,kCACT,mCAIjB,QACA,IASA,OACA,KAAgC,GAAK,WACrC,SACA,iBACA,IACA,cACA,iBACA,aAEA,GACU,GAAW,WAErB,gBAEA,cACA,CA1CA,EAEA,gBACA,oBACA,CA6DA,gBACA,aAEA,GADA,iBACA,EACA,YACA,KACA,IACA,cACA,mBAGA,yBACA,CACA,kBA3IA,KA2IA,SA3IA,IA2IA,eA3IA,KA2IA,SA3IA,IA2IA,KACA,cA5IA,KA4IA,SA5IA,IA4IA,eA5IA,KA4IA,SA5IA,IA4IA,MACc,IAAQ,KZnJE,aACxB,IAQA,EARA,OACA,OACA,OACA,OACA,IACA,IACA,MACA,MAIA,GADA,MACA,eAEA,GADA,KACA,KACA,aACA,WACA,EAAI,YACJ,aACA,WACA,CAGA,GADA,MACA,WAEA,GADA,KACA,KACA,aACA,WACA,EAAI,YACJ,aACA,WACA,CAGA,GADA,MACA,WAEA,GADA,KACA,KACA,aACA,WACA,EAAI,YACJ,aACA,WACA,CAGA,GADA,MACA,WAEA,GADA,KACA,KACA,aACA,WACA,EAAI,YACJ,aACA,WACA,CAIA,OAFA,6BACA,6BACA,KACA,EYyFsB,aAQV,IACZ,cACA,aACA,OAVA,IACA,cACA,oBAEA,mBACA,eACA,KAMA,CAEA,WACA,CAEA,QACA,CACA,EqB/GuG,8EA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A,IAWA,QAXA,OACA,OACA,QACA,EACA,MACA,EACA,MACA,EACA,EAEA,UAGA,UACA,OACA,OACA,MAEA,KACA,QAEA,KADA,UACA,QAEA,CADA,kBACA,KACA,MAGA,KACA,QACA,SACA,SACA,4BAEA,CADA,6BACA,0BACA,MAGA,KACA,QACA,SACA,SACA,SACA,0CACA,yCACA,kBACA,KAGA,CAGA,UAGA,QACA,KACM,UAEN,SACA,0BACA,gBAGA,UACA,IACA,KAUA,EARA,EASA,WACA,MAJA,KAKA,2CAMA,IAFA,SACA,IACA,KACA,6BACA,OACA,aAdA,OAiBA,QAtBA,CAmGA,kBACA,sDACA,kEACA,CAmLA,wBACA,iFACA,kEACA,sDACA,CA+LA,wBACA,iBACA,IADA,sCAEA,CAEA,sBAOA,OANA,KACA,OACA,GACA,sDAEA,sBACA,GACA,CAUA,sBAOA,OANA,KACA,OACA,GACA,wDAEA,sBACA,GACA,CA3+CA,IAAc,GAEd,IAAyB,IAmBzB,iCAYA,IACA,wBACA,GAAkB,eAAmB,YAGrC,OAFA,8CACA,2BACA,YACA,CAAI,SACJ,QACA,CACA,IAnBA,oDACA,kCACA,cACA,iJAkBA,4CACA,cACA,eACA,oBACA,mBAEA,CAAC,EAED,4CACA,cACA,eACA,oBACA,uBAEA,CAAC,EAmCD,gBAgEA,uBACA,eACA,EAIA,wDACA,oCA8BA,wBACA,MAnBA,CADA,EAoBA,GAnBA,MACA,EAkBA,GAhBA,SAgBA,EAZA,iBAYA,EAXA,EAWA,GAXA,KAWA,KAVA,EAUA,GAVA,KAUA,GARA,EAQA,EACA,EAUA,0BACA,WACA,EAIA,8BACA,WACA,EA6GA,uBACA,kCACA,eACA,EAEA,wBAGA,GAFA,qDACA,qDACA,+BACA,gBACA,yEAIA,kBAKA,QAHA,WACA,WAEA,oBAAwC,IAAS,IACjD,gBACA,OACA,OACA,KACA,QAGA,QACA,KAEA,EAEA,yBACA,gCACA,UACA,WACA,YACA,YACA,aACA,aACA,aACA,WACA,YACA,cACA,eACA,QACA,SACA,QACA,CACA,EAEA,uBACA,qBACA,+DAGA,gBACA,kBAIA,cAEA,QADA,IACgB,WAAiB,IACjC,eAIA,IARA,EAQA,mBACA,IACA,QAAc,WAAiB,KAC/B,WACA,mBACA,oBACA,oBAEA,8BACA,EACA,EACA,QAGM,iBAGN,iBAFA,+DAIA,YAEA,QACA,EAiDA,eA8EA,yBAQA,8BACA,kBACA,UACA,8DAEA,YAAkB,IAAS,KAC3B,cAEA,aAGA,8BACA,kBACA,UACA,8DAEA,YAAkB,IAAS,KAC3B,cACA,gBAEA,aAGA,8BACA,kBACA,UACA,8DAEA,YAAkB,IAAS,KAC3B,cACA,gBACA,gBACA,gBAEA,aAGA,gCACA,yBACA,SACA,gCACA,uBACA,EAEA,gDAEA,+BACA,sEACA,UACA,qBACA,EAEA,+BACA,SACA,EAAY,IAAyB,CAGrC,OAFA,uCAAiD,EAAE,kBACnD,4BACA,gBACA,EACA,GACA,qCAGA,wCAIA,GAHA,iBACA,oCAEA,eACA,gBACA,iFACA,UAiBA,GAbA,YACA,MAEA,YACA,iBAEA,YACA,MAEA,YACA,gBAGA,oCACA,uCAGA,cACA,SAEA,QACA,UAEA,QACA,SAQA,GALA,OACA,OACA,OACA,OAEA,kBASA,QAPA,MACA,MACA,gBAEA,kBACA,eAEA,IAAkB,IAAS,IAC3B,gBACA,OACA,OACA,KACA,QAGA,QACA,KAEA,EA2HA,qCACA,+BACA,EAEA,oCACA,uBACA,EAEA,wCACA,uBACA,EA2CA,oCAEA,cACA,SACA,cACA,SAEI,kCACJ,IACA,cACA,SAEI,eACJ,OACA,aACA,OACA,yBAEA,IACA,eAGA,YACA,2EAIA,IA3CA,IAIA,IAIA,IAIA,IA+BA,gBAGA,GAFA,yBAEA,sCACA,0DAGA,eAGA,IADA,GACS,CADT,OAEA,UACA,UACA,OAjFA,kBACA,eACA,iBACA,EAGA,cACA,GACA,MAJA,IAQA,eAEA,OACA,QAEA,YAAkB,IAAY,KAC9B,IA27BA,EA37BA,+BACA,GA47BA,CAFA,EA17BA,IA47BA,EA57BA,KACA,SACA,CACA,QACA,EA0DA,WAEA,YACA,YACA,OA5DA,EA4DA,EA5DA,EA4DA,EA3DA,IA2DA,EA3DA,IA2DA,CA3DA,UA2DA,KA3DA,IA6DA,aACA,aACA,aACA,OA7DA,EA6DA,EA7DA,EA6DA,EA5DA,WAk4BA,GAEA,QADA,KACA,IAAkB,WAAgB,IAElC,4BAEA,QACA,EA70BA,QA5DA,IA8DA,cAEA,OA7DA,EA6DA,EA7DA,EA6DA,EA5DA,IA4DA,QA5DA,IA8DA,YACA,YACA,cACA,eACA,OA/DA,EA+DA,EA/DA,EA+DA,EA9DA,WAm4BA,KAGA,QAFA,IACA,KACA,IAAkB,aAClB,WADkC,IAIlC,EADA,qBACA,EAEA,OADA,OAEA,UAGA,QACA,EAn1BA,OA9DA,UA8DA,KA9DA,IAgEA,SACA,6CACA,uBACA,IACA,CAEA,EAEA,8BACA,OACA,cACA,kDACA,CACA,EAwJA,gCACA,kBACA,MACA,mBAEA,IACA,OACA,SACI,KACJ,MAGA,IAEA,CADA,MACA,SACI,KACJ,MAGA,WAEA,yBAIA,OAFA,qCAEA,CACA,EAUA,uBACA,uCACA,OACA,OACA,sBAKA,IAHA,cACA,IACA,IACA,iBACA,eAGA,QACA,EAEA,uBACA,uCACA,OACA,OACA,GACA,mBAKA,IAFA,kBACA,IACA,eACA,iBAGA,QACA,EAEA,sBACA,oCAGA,OAFA,OACA,sBACA,SAGA,yBACA,uCAGA,OAFA,OACA,sBACA,oBACA,EAEA,yBACA,uCAGA,OAFA,OACA,sBACA,sBAGA,yBACA,uCAIA,OAHA,OACA,sBAEA,SACA,aACA,eACA,qBAGA,yBACA,uCAIA,OAHA,OACA,sBAEA,kBACA,eACA,aACA,UACA,EAEA,sCACA,OACA,OACA,sBAKA,IAHA,cACA,IACA,IACA,iBACA,eAMA,OAFA,GAFA,UAEA,qBAEA,CACA,EAEA,sCACA,OACA,OACA,sBAKA,IAHA,QACA,IACA,cACA,eACA,iBAMA,OAFA,GAFA,UAEA,qBAEA,CACA,EAEA,yCAGA,CAFA,OACA,sBACA,aACA,qBADA,SAIA,sCACA,OACA,sBACA,2BACA,6BACA,EAEA,sCACA,OACA,sBACA,2BACA,6BACA,EAEA,sCAIA,OAHA,OACA,sBAEA,QACA,aACA,cACA,aACA,EAEA,sCAIA,OAHA,OACA,sBAEA,YACA,cACA,aACA,WAGA,sCAGA,OAFA,OACA,sBACA,sBACA,EAEA,sCAGA,OAFA,OACA,sBACA,sBACA,EAEA,uCAGA,OAFA,OACA,sBACA,sBACA,EAEA,uCAGA,OAFA,OACA,sBACA,sBACA,EAQA,wBACA,0CAIA,GAHA,KACA,OACA,OACA,IACA,wBACA,iBACA,CAEA,QACA,IAEA,IADA,cACA,iBACA,kBAGA,UACA,EAEA,wBACA,0CAIA,GAHA,KACA,OACA,OACA,IACA,wBACA,iBACA,CAEA,UACA,IAEA,IADA,gBACA,kBACA,kBAGA,UACA,EAEA,uBACA,uCAKA,OAJA,KACA,OACA,uBACA,cACA,GACA,EAEA,0BACA,0CAMA,OALA,KACA,OACA,yBACA,cACA,gBACA,GACA,EAEA,0BACA,0CAMA,OALA,KACA,OACA,yBACA,cACA,gBACA,GACA,EAEA,0BACA,0CAQA,OAPA,KACA,OACA,8BACA,iBACA,iBACA,gBACA,cACA,GACA,EAEA,0BACA,0CAQA,OAPA,KACA,OACA,8BACA,eACA,iBACA,gBACA,gBACA,GACA,EAEA,yCAGA,GAFA,KACA,OACA,IACA,wBAEA,oBACA,CAEA,QACA,IACA,IAEA,IADA,cACA,iBACA,6BACA,MAEA,wBAGA,UACA,EAEA,yCAGA,GAFA,KACA,OACA,IACA,wBAEA,oBACA,CAEA,UACA,IACA,IAEA,IADA,gBACA,kBACA,6BACA,MAEA,wBAGA,UACA,EAEA,sCAMA,OALA,KACA,OACA,0BACA,iBACA,cACA,GACA,EAEA,yCAMA,OALA,KACA,OACA,8BACA,cACA,gBACA,GACA,EAEA,yCAMA,OALA,KACA,OACA,8BACA,cACA,gBACA,GACA,EAEA,yCAQA,OAPA,KACA,OACA,wCACA,cACA,gBACA,iBACA,iBACA,GACA,EAEA,yCASA,OARA,KACA,OACA,wCACA,wBACA,eACA,iBACA,gBACA,gBACA,GACA,EAiBA,yCACA,uBACA,EAEA,yCACA,uBACA,EAYA,0CACA,uBACA,EAEA,0CACA,uBACA,EAGA,mCACA,iEAQA,GAPA,SACA,0BACA,0BACA,SACA,gBAGA,OACA,8BADA,SAIA,OACA,8CAEA,8DACA,kDAGA,gCACA,gBACA,iBAGA,UAaA,OAXA,6DAEA,uBAEA,8BACA,EACA,mBACA,GAIA,CACA,EAMA,mCAEA,uBASA,GARA,oBACA,IACA,IACA,eACM,qBACN,IACA,eAEA,+BACA,6CAEA,wCACA,wCAEA,iBACA,IA2BA,EA3BA,iBACA,qBACA,eAEA,KAEA,CACA,EAAI,sBACJ,OACI,qBACJ,cAIA,qCACA,uCAGA,QACA,YASA,GANA,OACA,+BAEA,SAGA,mBACA,QAAoB,IAAS,IAC7B,cAEI,CACJ,oBACA,EACA,YACA,WACA,SACA,gCACA,qCAEA,QAAgB,MAAiB,IACjC,iBAIA,WACA,EAKA,0BAgBA,gBACA,SAMA,QALA,EACA,WACA,OACA,KAEA,IAAkB,IAAY,KAI9B,IAHA,mBAGA,gBAEA,OAEA,YAIU,QAJV,CAEA,+BACA,QACA,CAOA,CAPU,CAOV,EAEA,QACA,CAGA,YACA,+BACA,IACA,QACA,CAGA,6BACA,EAAM,OAEN,+BAMA,GAHA,OAGA,OACA,kBACA,SACA,EAAM,eACN,kBACA,OACA,SACA,SAEA,EAAM,gBACN,kBACA,OACA,UACA,YACA,SAEA,EAAM,kBACN,kBACA,OACA,UACA,aACA,YACA,SAEA,EAAM,IACN,iCAEA,CAEA,QACA,CA2BA,cACA,8BAxHA,GAMA,GAFA,GAFA,oBAEA,sBAEA,kBAEA,oBACA,OAEA,QACA,EA4GA,GACA,CAEA,oBACA,YAAkB,MAClB,gCAD8B,IAE9B,YAEA,QACA,CAKA,gBACA,uBACA,wDACA,2BACA,CAQA,iBAGA,QAFA,qBACA,aACA,IAAkB,KAAQ,IAE1B,QADA,OACA,IAAoB,KAAQ,IAC5B,iBAGA,QACA,CAAC,kBCvxDD,MAAY,qBAEZ,IADA,IACA,UACA,WACA,OACA,KACA,UACA,SACA,SAOA,IALA,KAEA,cACA,OACA,KACS,IAAW,0BAKpB,IAHA,cACA,OACA,KACS,IAAW,0BAEpB,SACA,UAGI,CAFA,SACJ,0BAEA,iBACA,IACA,CACA,gCACA,EAEA,OAAa,uBAEb,IADA,MACA,UACA,WACA,OACA,gCACA,UACA,SACA,uBAmCA,IA/BA,MAFA,gBAEA,SACA,cACA,MAEA,mCACA,yBACA,IACA,MAEA,OACA,OAEA,qBAEA,SACA,IACA,MAGA,QACA,IACA,KACM,QACN,wBACA,OAEA,kCACA,MAIS,KAAW,+BAIpB,IAFA,SACA,KACS,IAAU,+BAEnB,eACA,aCjFA,4BACA,kBACA,IACA,mBACA,yBAEA,QADA,MACA,UAAiC,IAAS,OAC1C,4BACA,wBACA,UACA,uBACA,MACA,CACA,QACA,gCCfA,MAAY,EAAQ,IAAO,EAC3B,EAAY,EAAQ,KAAW,EADZ,EAEE,EAAQ,KAAkB,CAD5B,CAEnB,EAAa,QADe,CACf,SAAyD,SAUtE,SAEA,6BAGA,OAGA,MAgLA,YAOA,QANA,OACA,OACA,OACA,OAGA,IAAoB,WAAmB,KACvC,UACA,kBACA,iBACA,iBACA,gBACA,CAZA,IAeA,YACA,YACA,QAAgB,WAAmB,IACnC,4BA8IA,EA1IA,EA2IA,UAGA,QADA,KACA,IAAoB,WAAmB,KACvC,0DACA,QAEA,YACA,CAGA,QADA,KACA,aAAqC,KAAS,KAC9C,0DACA,QAEA,YACA,CAIA,OAFA,QACA,QACA,WA9JA,EAxMA,GAGA,WACA,sBACA,OACA,UACA,UACA,UACA,UAEA,EACA,4BAAyC,kBACzC,4BAAyC,kBAEzC,UAIA,UADA,KACA,IAA0B,WAAiB,KAC3C,WACA,YACA,SACA,SACA,CANA,IASA,YACA,QAAgB,WAAkB,sBAMlC,IAJA,UACA,MAGA,WACA,gBACA,MACA,WAGA,SACA,WAEA,UAGA,YA6BA,eAMA,IALA,kBACA,SAIA,IACA,YAAwB,oBAA0B,KAClD,oBAEA,kBAkCA,gBACA,2BACA,yDACA,kBACA,yDACA,kBACA,yDACA,kBACA,gEACA,QACA,iBACA,EA7CA,OACA,KAEA,QACA,OACA,CAJ0C,IAI1C,CACA,CAAa,CACb,CAEA,yCACA,cACA,SAIA,WACA,WACA,uBACA,UACA,iBACA,CAEA,aACA,UACA,CAEA,WACA,EAlEA,oCAGA,6BAEA,UACA,eAGA,YACA,YACA,eACA,qBAEA,CAGA,IACA,SACA,GACA,YACA,eACM,OAIN,OAFA,YAEA,CACA,CAyCA,gBACA,qBAiBA,gBACA,qBACA,cACA,cACA,aAIA,kBAOA,QAWA,QAjBA,sBACA,sBACA,sBACA,sBAEA,YAAgC,4BAA+C,EAC/E,IAAoB,WAAkB,IACtC,IAUA,EAVA,OAUA,EAVA,YAUA,EAVA,EAWA,KADA,EAVA,IAWA,OACA,wBACA,uBAbA,SAEA,QACA,CAEA,kBACA,uCACA,CAUA,cACA,UACA,WAKA,OAJA,2BACA,2BACA,2BACA,2BACA,CACA,CA8BA,gBACA,OACA,IACA,UACA,UACA,OACA,OACA,OACA,MACA,EAYA,OAVA,GAKA,cACA,SACA,cACA,WAPA,SACA,UAQA,CACA,CAGA,gBAEA,gBACA,YAEA,cACA,CAGA,kBAEA,WACA,OACA,SACA,SAEA,iBAEA,uCAEA,MACA,OACA,QAEU,MACV,OACA,OAEA,CAKA,MAHA,WAGA,EAFA,WAEA,CACA,CAGA,4BACA,IAaA,QAbA,MACA,MACA,MACA,MACA,MACA,MACA,UACA,UACA,UACA,UACA,UACA,UAGA,IACA,GAEA,QACA,IACA,IACA,IACA,MAEA,UACA,UACA,KACA,IACA,IACA,KACU,MACV,IACA,MACA,MAIA,KACA,IACA,SACA,UAEA,KACA,MAEM,MACN,IACA,WACA,YAEA,OACA,MAIA,cAOA,MAFA,GAJA,eAIA,QAFA,cAKA,GAFA,WAFA,cAMA,cACA,CAEA,gBACA,uCA7VA,WACA,cAGA,YACA,iBAAsB","sources":["webpack://_N_E/./node_modules/rbush/rbush.min.js","webpack://_N_E/./node_modules/@turf/helpers/dist/esm/index.js","webpack://_N_E/./node_modules/maplibre-gl-indoorequal/maplibre-gl-indoorequal.css","webpack://_N_E/./node_modules/tinyqueue/index.js","webpack://_N_E/./node_modules/maplibre-gl/dist/maplibre-gl.css","webpack://_N_E/./node_modules/@turf/invariant/dist/esm/index.js","webpack://_N_E/./node_modules/@turf/distance/dist/esm/index.js","webpack://_N_E/./node_modules/@turf/meta/dist/esm/index.js","webpack://_N_E/./node_modules/robust-predicates/umd/orient2d.min.js","webpack://_N_E/./node_modules/@turf/polygon-smooth/dist/esm/index.js","webpack://_N_E/./node_modules/point-in-polygon/index.js","webpack://_N_E/./node_modules/@turf/convex/dist/esm/index.js","webpack://_N_E/./node_modules/maplibre-gl-indoorequal/dist/maplibre-gl-indoorequal.umd.min.js","webpack://_N_E/./node_modules/point-in-polygon/flat.js","webpack://_N_E/./node_modules/@turf/bbox/dist/esm/index.js","webpack://_N_E/./node_modules/@turf/center/dist/esm/index.js","webpack://_N_E/./node_modules/d3-geo/src/adder.js","webpack://_N_E/./node_modules/d3-geo/src/math.js","webpack://_N_E/./node_modules/d3-geo/src/noop.js","webpack://_N_E/./node_modules/d3-geo/src/stream.js","webpack://_N_E/./node_modules/d3-geo/src/area.js","webpack://_N_E/./node_modules/d3-geo/src/cartesian.js","webpack://_N_E/./node_modules/d3-geo/src/bounds.js","webpack://_N_E/./node_modules/d3-geo/src/centroid.js","webpack://_N_E/./node_modules/d3-geo/src/compose.js","webpack://_N_E/./node_modules/d3-geo/src/rotation.js","webpack://_N_E/./node_modules/d3-geo/src/circle.js","webpack://_N_E/./node_modules/d3-geo/src/clip/buffer.js","webpack://_N_E/./node_modules/d3-geo/src/clip/line.js","webpack://_N_E/./node_modules/d3-geo/src/pointEqual.js","webpack://_N_E/./node_modules/d3-geo/src/clip/polygon.js","webpack://_N_E/./node_modules/d3-array/src/ascending.js","webpack://_N_E/./node_modules/d3-array/src/bisector.js","webpack://_N_E/./node_modules/d3-array/src/bisect.js","webpack://_N_E/./node_modules/d3-array/src/array.js","webpack://_N_E/./node_modules/d3-array/src/ticks.js","webpack://_N_E/./node_modules/d3-array/src/histogram.js","webpack://_N_E/./node_modules/d3-array/src/threshold/freedmanDiaconis.js","webpack://_N_E/./node_modules/d3-array/src/merge.js","webpack://_N_E/./node_modules/d3-array/src/index.js","webpack://_N_E/./node_modules/d3-geo/src/clip/extent.js","webpack://_N_E/./node_modules/d3-geo/src/polygonContains.js","webpack://_N_E/./node_modules/d3-geo/src/length.js","webpack://_N_E/./node_modules/d3-geo/src/distance.js","webpack://_N_E/./node_modules/d3-geo/src/contains.js","webpack://_N_E/./node_modules/d3-geo/src/graticule.js","webpack://_N_E/./node_modules/d3-geo/src/interpolate.js","webpack://_N_E/./node_modules/d3-geo/src/path/area.js","webpack://_N_E/./node_modules/d3-geo/src/path/bounds.js","webpack://_N_E/./node_modules/d3-geo/src/path/centroid.js","webpack://_N_E/./node_modules/d3-geo/src/path/context.js","webpack://_N_E/./node_modules/d3-geo/src/path/measure.js","webpack://_N_E/./node_modules/d3-geo/src/path/string.js","webpack://_N_E/./node_modules/d3-geo/src/path/index.js","webpack://_N_E/./node_modules/d3-geo/src/clip/index.js","webpack://_N_E/./node_modules/d3-geo/src/clip/antimeridian.js","webpack://_N_E/./node_modules/d3-geo/src/clip/circle.js","webpack://_N_E/./node_modules/d3-geo/src/identity.js","webpack://_N_E/./node_modules/d3-geo/src/transform.js","webpack://_N_E/./node_modules/d3-geo/src/projection/fit.js","webpack://_N_E/./node_modules/d3-geo/src/projection/resample.js","webpack://_N_E/./node_modules/d3-geo/src/projection/index.js","webpack://_N_E/./node_modules/d3-geo/src/projection/conic.js","webpack://_N_E/./node_modules/d3-geo/src/projection/cylindricalEqualArea.js","webpack://_N_E/./node_modules/d3-geo/src/projection/conicEqualArea.js","webpack://_N_E/./node_modules/d3-geo/src/projection/albers.js","webpack://_N_E/./node_modules/d3-geo/src/projection/albersUsa.js","webpack://_N_E/./node_modules/d3-geo/src/projection/azimuthal.js","webpack://_N_E/./node_modules/d3-geo/src/projection/azimuthalEqualArea.js","webpack://_N_E/./node_modules/d3-geo/src/projection/azimuthalEquidistant.js","webpack://_N_E/./node_modules/d3-geo/src/projection/mercator.js","webpack://_N_E/./node_modules/d3-geo/src/projection/conicConformal.js","webpack://_N_E/./node_modules/d3-geo/src/projection/equirectangular.js","webpack://_N_E/./node_modules/d3-geo/src/projection/conicEquidistant.js","webpack://_N_E/./node_modules/d3-geo/src/projection/gnomonic.js","webpack://_N_E/./node_modules/d3-geo/src/projection/identity.js","webpack://_N_E/./node_modules/d3-geo/src/projection/naturalEarth1.js","webpack://_N_E/./node_modules/d3-geo/src/projection/orthographic.js","webpack://_N_E/./node_modules/d3-geo/src/projection/stereographic.js","webpack://_N_E/./node_modules/d3-geo/src/projection/transverseMercator.js","webpack://_N_E/./node_modules/d3-geo/index.js","webpack://_N_E/./node_modules/@turf/buffer/dist/esm/index.js","webpack://_N_E/./node_modules/@teritorio/openmaptiles-gl-language/dist/openmaptiles_gl_language.esm.js","webpack://_N_E/./node_modules/lodash/throttle.js","webpack://_N_E/./node_modules/base64-js/index.js","webpack://_N_E/./node_modules/buffer/index.js","webpack://_N_E/./node_modules/ieee754/index.js","webpack://_N_E/./node_modules/point-in-polygon/nested.js","webpack://_N_E/./node_modules/concaveman/index.js"],"sourcesContent":["!function(t,i){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=i():\"function\"==typeof define&&define.amd?define(i):(t=t||self).RBush=i()}(this,function(){\"use strict\";function t(t,r,e,a,h){!function t(n,r,e,a,h){for(;a>e;){if(a-e>600){var o=a-e+1,s=r-e+1,l=Math.log(o),f=.5*Math.exp(2*l/3),u=.5*Math.sqrt(l*f*(o-f)/o)*(s-o/2<0?-1:1),m=Math.max(e,Math.floor(r-s*f/o+u)),c=Math.min(a,Math.floor(r+(o-s)*f/o+u));t(n,r,m,c,h)}var p=n[r],d=e,x=a;for(i(n,e,r),h(n[a],p)>0&&i(n,e,a);d<x;){for(i(n,d,x),d++,x--;h(n[d],p)<0;)d++;for(;h(n[x],p)>0;)x--}0===h(n[e],p)?i(n,e,x):i(n,++x,a),x<=r&&(e=x+1),r<=x&&(a=x-1)}}(t,r,e||0,a||t.length-1,h||n)}function i(t,i,n){var r=t[i];t[i]=t[n],t[n]=r}function n(t,i){return t<i?-1:t>i?1:0}var r=function(t){void 0===t&&(t=9),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function e(t,i,n){if(!n)return i.indexOf(t);for(var r=0;r<i.length;r++)if(n(t,i[r]))return r;return-1}function a(t,i){h(t,0,t.children.length,i,t)}function h(t,i,n,r,e){e||(e=p(null)),e.minX=1/0,e.minY=1/0,e.maxX=-1/0,e.maxY=-1/0;for(var a=i;a<n;a++){var h=t.children[a];o(e,t.leaf?r(h):h)}return e}function o(t,i){return t.minX=Math.min(t.minX,i.minX),t.minY=Math.min(t.minY,i.minY),t.maxX=Math.max(t.maxX,i.maxX),t.maxY=Math.max(t.maxY,i.maxY),t}function s(t,i){return t.minX-i.minX}function l(t,i){return t.minY-i.minY}function f(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function u(t){return t.maxX-t.minX+(t.maxY-t.minY)}function m(t,i){return t.minX<=i.minX&&t.minY<=i.minY&&i.maxX<=t.maxX&&i.maxY<=t.maxY}function c(t,i){return i.minX<=t.maxX&&i.minY<=t.maxY&&i.maxX>=t.minX&&i.maxY>=t.minY}function p(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function d(i,n,r,e,a){for(var h=[n,r];h.length;)if(!((r=h.pop())-(n=h.pop())<=e)){var o=n+Math.ceil((r-n)/e/2)*e;t(i,o,n,r,a),h.push(n,o,o,r)}}return r.prototype.all=function(){return this._all(this.data,[])},r.prototype.search=function(t){var i=this.data,n=[];if(!c(t,i))return n;for(var r=this.toBBox,e=[];i;){for(var a=0;a<i.children.length;a++){var h=i.children[a],o=i.leaf?r(h):h;c(t,o)&&(i.leaf?n.push(h):m(t,o)?this._all(h,n):e.push(h))}i=e.pop()}return n},r.prototype.collides=function(t){var i=this.data;if(!c(t,i))return!1;for(var n=[];i;){for(var r=0;r<i.children.length;r++){var e=i.children[r],a=i.leaf?this.toBBox(e):e;if(c(t,a)){if(i.leaf||m(t,a))return!0;n.push(e)}}i=n.pop()}return!1},r.prototype.load=function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var i=0;i<t.length;i++)this.insert(t[i]);return this}var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this._splitRoot(this.data,n);else{if(this.data.height<n.height){var r=this.data;this.data=n,n=r}this._insert(n,this.data.height-n.height-1,!0)}else this.data=n;return this},r.prototype.insert=function(t){return t&&this._insert(t,this.data.height-1),this},r.prototype.clear=function(){return this.data=p([]),this},r.prototype.remove=function(t,i){if(!t)return this;for(var n,r,a,h=this.data,o=this.toBBox(t),s=[],l=[];h||s.length;){if(h||(h=s.pop(),r=s[s.length-1],n=l.pop(),a=!0),h.leaf){var f=e(t,h.children,i);if(-1!==f)return h.children.splice(f,1),s.push(h),this._condense(s),this}a||h.leaf||!m(h,o)?r?(n++,h=r.children[n],a=!1):h=null:(s.push(h),l.push(n),n=0,r=h,h=h.children[0])}return this},r.prototype.toBBox=function(t){return t},r.prototype.compareMinX=function(t,i){return t.minX-i.minX},r.prototype.compareMinY=function(t,i){return t.minY-i.minY},r.prototype.toJSON=function(){return this.data},r.prototype.fromJSON=function(t){return this.data=t,this},r.prototype._all=function(t,i){for(var n=[];t;)t.leaf?i.push.apply(i,t.children):n.push.apply(n,t.children),t=n.pop();return i},r.prototype._build=function(t,i,n,r){var e,h=n-i+1,o=this._maxEntries;if(h<=o)return a(e=p(t.slice(i,n+1)),this.toBBox),e;r||(r=Math.ceil(Math.log(h)/Math.log(o)),o=Math.ceil(h/Math.pow(o,r-1))),(e=p([])).leaf=!1,e.height=r;var s=Math.ceil(h/o),l=s*Math.ceil(Math.sqrt(o));d(t,i,n,l,this.compareMinX);for(var f=i;f<=n;f+=l){var u=Math.min(f+l-1,n);d(t,f,u,s,this.compareMinY);for(var m=f;m<=u;m+=s){var c=Math.min(m+s-1,u);e.children.push(this._build(t,m,c,r-1))}}return a(e,this.toBBox),e},r.prototype._chooseSubtree=function(t,i,n,r){for(;r.push(i),!i.leaf&&r.length-1!==n;){for(var e=1/0,a=1/0,h=void 0,o=0;o<i.children.length;o++){var s=i.children[o],l=f(s),u=(m=t,c=s,(Math.max(c.maxX,m.maxX)-Math.min(c.minX,m.minX))*(Math.max(c.maxY,m.maxY)-Math.min(c.minY,m.minY))-l);u<a?(a=u,e=l<e?l:e,h=s):u===a&&l<e&&(e=l,h=s)}i=h||i.children[0]}var m,c;return i},r.prototype._insert=function(t,i,n){var r=n?t:this.toBBox(t),e=[],a=this._chooseSubtree(r,this.data,i,e);for(a.children.push(t),o(a,r);i>=0&&e[i].children.length>this._maxEntries;)this._split(e,i),i--;this._adjustParentBBoxes(r,e,i)},r.prototype._split=function(t,i){var n=t[i],r=n.children.length,e=this._minEntries;this._chooseSplitAxis(n,e,r);var h=this._chooseSplitIndex(n,e,r),o=p(n.children.splice(h,n.children.length-h));o.height=n.height,o.leaf=n.leaf,a(n,this.toBBox),a(o,this.toBBox),i?t[i-1].children.push(o):this._splitRoot(n,o)},r.prototype._splitRoot=function(t,i){this.data=p([t,i]),this.data.height=t.height+1,this.data.leaf=!1,a(this.data,this.toBBox)},r.prototype._chooseSplitIndex=function(t,i,n){for(var r,e,a,o,s,l,u,m=1/0,c=1/0,p=i;p<=n-i;p++){var d=h(t,0,p,this.toBBox),x=h(t,p,n,this.toBBox),v=(e=d,a=x,o=void 0,s=void 0,l=void 0,u=void 0,o=Math.max(e.minX,a.minX),s=Math.max(e.minY,a.minY),l=Math.min(e.maxX,a.maxX),u=Math.min(e.maxY,a.maxY),Math.max(0,l-o)*Math.max(0,u-s)),M=f(d)+f(x);v<m?(m=v,r=p,c=M<c?M:c):v===m&&M<c&&(c=M,r=p)}return r||n-i},r.prototype._chooseSplitAxis=function(t,i,n){var r=t.leaf?this.compareMinX:s,e=t.leaf?this.compareMinY:l;this._allDistMargin(t,i,n,r)<this._allDistMargin(t,i,n,e)&&t.children.sort(r)},r.prototype._allDistMargin=function(t,i,n,r){t.children.sort(r);for(var e=this.toBBox,a=h(t,0,i,e),s=h(t,n-i,n,e),l=u(a)+u(s),f=i;f<n-i;f++){var m=t.children[f];o(a,t.leaf?e(m):m),l+=u(a)}for(var c=n-i-1;c>=i;c--){var p=t.children[c];o(s,t.leaf?e(p):p),l+=u(s)}return l},r.prototype._adjustParentBBoxes=function(t,i,n){for(var r=n;r>=0;r--)o(i[r],t)},r.prototype._condense=function(t){for(var i=t.length-1,n=void 0;i>=0;i--)0===t[i].children.length?i>0?(n=t[i-1].children).splice(n.indexOf(t[i]),1):this.clear():a(t[i],this.toBBox)},r});\n","// index.ts\nvar earthRadius = 63710088e-1;\nvar factors = {\n  centimeters: earthRadius * 100,\n  centimetres: earthRadius * 100,\n  degrees: 360 / (2 * Math.PI),\n  feet: earthRadius * 3.28084,\n  inches: earthRadius * 39.37,\n  kilometers: earthRadius / 1e3,\n  kilometres: earthRadius / 1e3,\n  meters: earthRadius,\n  metres: earthRadius,\n  miles: earthRadius / 1609.344,\n  millimeters: earthRadius * 1e3,\n  millimetres: earthRadius * 1e3,\n  nauticalmiles: earthRadius / 1852,\n  radians: 1,\n  yards: earthRadius * 1.0936\n};\nvar areaFactors = {\n  acres: 247105e-9,\n  centimeters: 1e4,\n  centimetres: 1e4,\n  feet: 10.763910417,\n  hectares: 1e-4,\n  inches: 1550.003100006,\n  kilometers: 1e-6,\n  kilometres: 1e-6,\n  meters: 1,\n  metres: 1,\n  miles: 386e-9,\n  nauticalmiles: 29155334959812285e-23,\n  millimeters: 1e6,\n  millimetres: 1e6,\n  yards: 1.195990046\n};\nfunction feature(geom, properties, options = {}) {\n  const feat = { type: \"Feature\" };\n  if (options.id === 0 || options.id) {\n    feat.id = options.id;\n  }\n  if (options.bbox) {\n    feat.bbox = options.bbox;\n  }\n  feat.properties = properties || {};\n  feat.geometry = geom;\n  return feat;\n}\nfunction geometry(type, coordinates, _options = {}) {\n  switch (type) {\n    case \"Point\":\n      return point(coordinates).geometry;\n    case \"LineString\":\n      return lineString(coordinates).geometry;\n    case \"Polygon\":\n      return polygon(coordinates).geometry;\n    case \"MultiPoint\":\n      return multiPoint(coordinates).geometry;\n    case \"MultiLineString\":\n      return multiLineString(coordinates).geometry;\n    case \"MultiPolygon\":\n      return multiPolygon(coordinates).geometry;\n    default:\n      throw new Error(type + \" is invalid\");\n  }\n}\nfunction point(coordinates, properties, options = {}) {\n  if (!coordinates) {\n    throw new Error(\"coordinates is required\");\n  }\n  if (!Array.isArray(coordinates)) {\n    throw new Error(\"coordinates must be an Array\");\n  }\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be at least 2 numbers long\");\n  }\n  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n    throw new Error(\"coordinates must contain numbers\");\n  }\n  const geom = {\n    type: \"Point\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction points(coordinates, properties, options = {}) {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return point(coords, properties);\n    }),\n    options\n  );\n}\nfunction polygon(coordinates, properties, options = {}) {\n  for (const ring of coordinates) {\n    if (ring.length < 4) {\n      throw new Error(\n        \"Each LinearRing of a Polygon must have 4 or more Positions.\"\n      );\n    }\n    if (ring[ring.length - 1].length !== ring[0].length) {\n      throw new Error(\"First and last Position are not equivalent.\");\n    }\n    for (let j = 0; j < ring[ring.length - 1].length; j++) {\n      if (ring[ring.length - 1][j] !== ring[0][j]) {\n        throw new Error(\"First and last Position are not equivalent.\");\n      }\n    }\n  }\n  const geom = {\n    type: \"Polygon\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction polygons(coordinates, properties, options = {}) {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return polygon(coords, properties);\n    }),\n    options\n  );\n}\nfunction lineString(coordinates, properties, options = {}) {\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be an array of two or more positions\");\n  }\n  const geom = {\n    type: \"LineString\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction lineStrings(coordinates, properties, options = {}) {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return lineString(coords, properties);\n    }),\n    options\n  );\n}\nfunction featureCollection(features, options = {}) {\n  const fc = { type: \"FeatureCollection\" };\n  if (options.id) {\n    fc.id = options.id;\n  }\n  if (options.bbox) {\n    fc.bbox = options.bbox;\n  }\n  fc.features = features;\n  return fc;\n}\nfunction multiLineString(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiLineString\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction multiPoint(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiPoint\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction multiPolygon(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiPolygon\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\nfunction geometryCollection(geometries, properties, options = {}) {\n  const geom = {\n    type: \"GeometryCollection\",\n    geometries\n  };\n  return feature(geom, properties, options);\n}\nfunction round(num, precision = 0) {\n  if (precision && !(precision >= 0)) {\n    throw new Error(\"precision must be a positive number\");\n  }\n  const multiplier = Math.pow(10, precision || 0);\n  return Math.round(num * multiplier) / multiplier;\n}\nfunction radiansToLength(radians, units = \"kilometers\") {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return radians * factor;\n}\nfunction lengthToRadians(distance, units = \"kilometers\") {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return distance / factor;\n}\nfunction lengthToDegrees(distance, units) {\n  return radiansToDegrees(lengthToRadians(distance, units));\n}\nfunction bearingToAzimuth(bearing) {\n  let angle = bearing % 360;\n  if (angle < 0) {\n    angle += 360;\n  }\n  return angle;\n}\nfunction azimuthToBearing(angle) {\n  angle = angle % 360;\n  if (angle > 180) {\n    return angle - 360;\n  } else if (angle < -180) {\n    return angle + 360;\n  }\n  return angle;\n}\nfunction radiansToDegrees(radians) {\n  const normalisedRadians = radians % (2 * Math.PI);\n  return normalisedRadians * 180 / Math.PI;\n}\nfunction degreesToRadians(degrees) {\n  const normalisedDegrees = degrees % 360;\n  return normalisedDegrees * Math.PI / 180;\n}\nfunction convertLength(length, originalUnit = \"kilometers\", finalUnit = \"kilometers\") {\n  if (!(length >= 0)) {\n    throw new Error(\"length must be a positive number\");\n  }\n  return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nfunction convertArea(area, originalUnit = \"meters\", finalUnit = \"kilometers\") {\n  if (!(area >= 0)) {\n    throw new Error(\"area must be a positive number\");\n  }\n  const startFactor = areaFactors[originalUnit];\n  if (!startFactor) {\n    throw new Error(\"invalid original units\");\n  }\n  const finalFactor = areaFactors[finalUnit];\n  if (!finalFactor) {\n    throw new Error(\"invalid final units\");\n  }\n  return area / startFactor * finalFactor;\n}\nfunction isNumber(num) {\n  return !isNaN(num) && num !== null && !Array.isArray(num);\n}\nfunction isObject(input) {\n  return input !== null && typeof input === \"object\" && !Array.isArray(input);\n}\nfunction validateBBox(bbox) {\n  if (!bbox) {\n    throw new Error(\"bbox is required\");\n  }\n  if (!Array.isArray(bbox)) {\n    throw new Error(\"bbox must be an Array\");\n  }\n  if (bbox.length !== 4 && bbox.length !== 6) {\n    throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n  }\n  bbox.forEach((num) => {\n    if (!isNumber(num)) {\n      throw new Error(\"bbox must only contain numbers\");\n    }\n  });\n}\nfunction validateId(id) {\n  if (!id) {\n    throw new Error(\"id is required\");\n  }\n  if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n    throw new Error(\"id must be a number or a string\");\n  }\n}\nexport {\n  areaFactors,\n  azimuthToBearing,\n  bearingToAzimuth,\n  convertArea,\n  convertLength,\n  degreesToRadians,\n  earthRadius,\n  factors,\n  feature,\n  featureCollection,\n  geometry,\n  geometryCollection,\n  isNumber,\n  isObject,\n  lengthToDegrees,\n  lengthToRadians,\n  lineString,\n  lineStrings,\n  multiLineString,\n  multiPoint,\n  multiPolygon,\n  point,\n  points,\n  polygon,\n  polygons,\n  radiansToDegrees,\n  radiansToLength,\n  round,\n  validateBBox,\n  validateId\n};\n//# sourceMappingURL=index.js.map","// extracted by mini-css-extract-plugin","\nexport default class TinyQueue {\n    constructor(data = [], compare = defaultCompare) {\n        this.data = data;\n        this.length = this.data.length;\n        this.compare = compare;\n\n        if (this.length > 0) {\n            for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n        }\n    }\n\n    push(item) {\n        this.data.push(item);\n        this.length++;\n        this._up(this.length - 1);\n    }\n\n    pop() {\n        if (this.length === 0) return undefined;\n\n        const top = this.data[0];\n        const bottom = this.data.pop();\n        this.length--;\n\n        if (this.length > 0) {\n            this.data[0] = bottom;\n            this._down(0);\n        }\n\n        return top;\n    }\n\n    peek() {\n        return this.data[0];\n    }\n\n    _up(pos) {\n        const {data, compare} = this;\n        const item = data[pos];\n\n        while (pos > 0) {\n            const parent = (pos - 1) >> 1;\n            const current = data[parent];\n            if (compare(item, current) >= 0) break;\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    }\n\n    _down(pos) {\n        const {data, compare} = this;\n        const halfLength = this.length >> 1;\n        const item = data[pos];\n\n        while (pos < halfLength) {\n            let left = (pos << 1) + 1;\n            let best = data[left];\n            const right = left + 1;\n\n            if (right < this.length && compare(data[right], best) < 0) {\n                left = right;\n                best = data[right];\n            }\n            if (compare(best, item) >= 0) break;\n\n            data[pos] = best;\n            pos = left;\n        }\n\n        data[pos] = item;\n    }\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n","// extracted by mini-css-extract-plugin","// index.ts\nimport { isNumber } from \"@turf/helpers\";\nfunction getCoord(coord) {\n  if (!coord) {\n    throw new Error(\"coord is required\");\n  }\n  if (!Array.isArray(coord)) {\n    if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\n      return [...coord.geometry.coordinates];\n    }\n    if (coord.type === \"Point\") {\n      return [...coord.coordinates];\n    }\n  }\n  if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\n    return [...coord];\n  }\n  throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\nfunction getCoords(coords) {\n  if (Array.isArray(coords)) {\n    return coords;\n  }\n  if (coords.type === \"Feature\") {\n    if (coords.geometry !== null) {\n      return coords.geometry.coordinates;\n    }\n  } else {\n    if (coords.coordinates) {\n      return coords.coordinates;\n    }\n  }\n  throw new Error(\n    \"coords must be GeoJSON Feature, Geometry Object or an Array\"\n  );\n}\nfunction containsNumber(coordinates) {\n  if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n    return true;\n  }\n  if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n    return containsNumber(coordinates[0]);\n  }\n  throw new Error(\"coordinates must only contain numbers\");\n}\nfunction geojsonType(value, type, name) {\n  if (!type || !name) {\n    throw new Error(\"type and name required\");\n  }\n  if (!value || value.type !== type) {\n    throw new Error(\n      \"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type\n    );\n  }\n}\nfunction featureOf(feature, type, name) {\n  if (!feature) {\n    throw new Error(\"No feature passed\");\n  }\n  if (!name) {\n    throw new Error(\".featureOf() requires a name\");\n  }\n  if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n    throw new Error(\n      \"Invalid input to \" + name + \", Feature with geometry required\"\n    );\n  }\n  if (!feature.geometry || feature.geometry.type !== type) {\n    throw new Error(\n      \"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type\n    );\n  }\n}\nfunction collectionOf(featureCollection, type, name) {\n  if (!featureCollection) {\n    throw new Error(\"No featureCollection passed\");\n  }\n  if (!name) {\n    throw new Error(\".collectionOf() requires a name\");\n  }\n  if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n    throw new Error(\n      \"Invalid input to \" + name + \", FeatureCollection required\"\n    );\n  }\n  for (const feature of featureCollection.features) {\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n      throw new Error(\n        \"Invalid input to \" + name + \", Feature with geometry required\"\n      );\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n      throw new Error(\n        \"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type\n      );\n    }\n  }\n}\nfunction getGeom(geojson) {\n  if (geojson.type === \"Feature\") {\n    return geojson.geometry;\n  }\n  return geojson;\n}\nfunction getType(geojson, _name) {\n  if (geojson.type === \"FeatureCollection\") {\n    return \"FeatureCollection\";\n  }\n  if (geojson.type === \"GeometryCollection\") {\n    return \"GeometryCollection\";\n  }\n  if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n    return geojson.geometry.type;\n  }\n  return geojson.type;\n}\nexport {\n  collectionOf,\n  containsNumber,\n  featureOf,\n  geojsonType,\n  getCoord,\n  getCoords,\n  getGeom,\n  getType\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { getCoord } from \"@turf/invariant\";\nimport { radiansToLength, degreesToRadians } from \"@turf/helpers\";\nfunction distance(from, to, options = {}) {\n  var coordinates1 = getCoord(from);\n  var coordinates2 = getCoord(to);\n  var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);\n  var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);\n  var lat1 = degreesToRadians(coordinates1[1]);\n  var lat2 = degreesToRadians(coordinates2[1]);\n  var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n  return radiansToLength(\n    2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)),\n    options.units\n  );\n}\nvar turf_distance_default = distance;\nexport {\n  turf_distance_default as default,\n  distance\n};\n//# sourceMappingURL=index.js.map","// index.js\nimport { feature, point, lineString, isObject } from \"@turf/helpers\";\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  if (geojson === null) return;\n  var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === \"FeatureCollection\", isFeature = type === \"Feature\", stop = isFeatureCollection ? geojson.features.length : 1;\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n      wrapShrink = excludeWrapCoord && (geomType === \"Polygon\" || geomType === \"MultiPolygon\") ? 1 : 0;\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (callback(\n            coords,\n            coordIndex,\n            featureIndex,\n            multiFeatureIndex,\n            geometryIndex\n          ) === false)\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (callback(\n              coords[j],\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false)\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (callback(\n                coords[j][k],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false)\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (callback(\n                  coords[j][k][l],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false)\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (coordIndex === 0 && initialValue === void 0)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function(currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === void 0)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function(currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === void 0)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function(coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\nfunction geomEach(geojson, callback) {\n  var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === \"FeatureCollection\", isFeature = geojson.type === \"Feature\", stop = isFeatureCollection ? geojson.features.length : 1;\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;\n    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};\n    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;\n    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;\n    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === \"GeometryCollection\" : false;\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n      if (geometry === null) {\n        if (callback(\n          null,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        ) === false)\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (callback(\n            geometry,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false)\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (callback(\n              geometry.geometries[j],\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false)\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    featureIndex++;\n  }\n}\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n      if (featureIndex === 0 && initialValue === void 0)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function(geometry, featureIndex, properties, bbox, id) {\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (callback(\n          feature(geometry, properties, { bbox, id }),\n          featureIndex,\n          0\n        ) === false)\n          return false;\n        return;\n    }\n    var geomType;\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate\n      };\n      if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false)\n        return false;\n    }\n  });\n}\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function(currentFeature, featureIndex, multiFeatureIndex) {\n      if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === void 0)\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n    if (!feature2.geometry) return;\n    var type = feature2.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (coordEach(\n      feature2,\n      function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n        if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n          previousCoords = currentCoord;\n          previousFeatureIndex = featureIndex;\n          previousMultiIndex = multiPartIndexCoord;\n          prevGeomIndex = geometryIndex;\n          segmentIndex = 0;\n          return;\n        }\n        var currentSegment = lineString(\n          [previousCoords, currentCoord],\n          feature2.properties\n        );\n        if (callback(\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        ) === false)\n          return false;\n        segmentIndex++;\n        previousCoords = currentCoord;\n      }\n    ) === false)\n      return false;\n  });\n}\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n      if (started === false && initialValue === void 0)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\nfunction lineEach(geojson, callback) {\n  if (!geojson) throw new Error(\"geojson is required\");\n  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {\n    if (feature2.geometry === null) return;\n    var type = feature2.geometry.type;\n    var coords = feature2.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature2, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n          if (callback(\n            lineString(coords[geometryIndex], feature2.properties),\n            featureIndex,\n            multiFeatureIndex,\n            geometryIndex\n          ) === false)\n            return false;\n        }\n        break;\n    }\n  });\n}\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function(currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === void 0)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\nfunction findSegment(geojson, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\nfunction findPoint(geojson, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n  var properties = options.properties;\n  var geometry;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\nexport {\n  coordAll,\n  coordEach,\n  coordReduce,\n  featureEach,\n  featureReduce,\n  findPoint,\n  findSegment,\n  flattenEach,\n  flattenReduce,\n  geomEach,\n  geomReduce,\n  lineEach,\n  lineReduce,\n  propEach,\n  propReduce,\n  segmentEach,\n  segmentReduce\n};\n//# sourceMappingURL=index.js.map","!function(t,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?e(exports):\"function\"==typeof define&&define.amd?define([\"exports\"],e):e((t=t||self).predicates={})}(this,function(t){\"use strict\";const e=134217729,n=33306690738754706e-32;function r(t,e,n,r,o){let f,i,u,c,s=e[0],a=r[0],d=0,l=0;a>s==a>-s?(f=s,s=e[++d]):(f=a,a=r[++l]);let p=0;if(d<t&&l<n)for(a>s==a>-s?(u=f-((i=s+f)-s),s=e[++d]):(u=f-((i=a+f)-a),a=r[++l]),f=i,0!==u&&(o[p++]=u);d<t&&l<n;)a>s==a>-s?(u=f-((i=f+s)-(c=i-f))+(s-c),s=e[++d]):(u=f-((i=f+a)-(c=i-f))+(a-c),a=r[++l]),f=i,0!==u&&(o[p++]=u);for(;d<t;)u=f-((i=f+s)-(c=i-f))+(s-c),s=e[++d],f=i,0!==u&&(o[p++]=u);for(;l<n;)u=f-((i=f+a)-(c=i-f))+(a-c),a=r[++l],f=i,0!==u&&(o[p++]=u);return 0===f&&0!==p||(o[p++]=f),p}function o(t){return new Float64Array(t)}const f=33306690738754716e-32,i=22204460492503146e-32,u=11093356479670487e-47,c=o(4),s=o(8),a=o(12),d=o(16),l=o(4);t.orient2d=function(t,o,p,b,y,h){const M=(o-h)*(p-y),x=(t-y)*(b-h),j=M-x;if(0===M||0===x||M>0!=x>0)return j;const m=Math.abs(M+x);return Math.abs(j)>=f*m?j:-function(t,o,f,p,b,y,h){let M,x,j,m,_,v,w,A,F,O,P,g,k,q,z,B,C,D;const E=t-b,G=f-b,H=o-y,I=p-y;_=(z=(A=E-(w=(v=e*E)-(v-E)))*(O=I-(F=(v=e*I)-(v-I)))-((q=E*I)-w*F-A*F-w*O))-(P=z-(C=(A=H-(w=(v=e*H)-(v-H)))*(O=G-(F=(v=e*G)-(v-G)))-((B=H*G)-w*F-A*F-w*O))),c[0]=z-(P+_)+(_-C),_=(k=q-((g=q+P)-(_=g-q))+(P-_))-(P=k-B),c[1]=k-(P+_)+(_-B),_=(D=g+P)-g,c[2]=g-(D-_)+(P-_),c[3]=D;let J=function(t,e){let n=e[0];for(let r=1;r<t;r++)n+=e[r];return n}(4,c),K=i*h;if(J>=K||-J>=K)return J;if(M=t-(E+(_=t-E))+(_-b),j=f-(G+(_=f-G))+(_-b),x=o-(H+(_=o-H))+(_-y),m=p-(I+(_=p-I))+(_-y),0===M&&0===x&&0===j&&0===m)return J;if(K=u*h+n*Math.abs(J),(J+=E*m+I*M-(H*j+G*x))>=K||-J>=K)return J;_=(z=(A=M-(w=(v=e*M)-(v-M)))*(O=I-(F=(v=e*I)-(v-I)))-((q=M*I)-w*F-A*F-w*O))-(P=z-(C=(A=x-(w=(v=e*x)-(v-x)))*(O=G-(F=(v=e*G)-(v-G)))-((B=x*G)-w*F-A*F-w*O))),l[0]=z-(P+_)+(_-C),_=(k=q-((g=q+P)-(_=g-q))+(P-_))-(P=k-B),l[1]=k-(P+_)+(_-B),_=(D=g+P)-g,l[2]=g-(D-_)+(P-_),l[3]=D;const L=r(4,c,4,l,s);_=(z=(A=E-(w=(v=e*E)-(v-E)))*(O=m-(F=(v=e*m)-(v-m)))-((q=E*m)-w*F-A*F-w*O))-(P=z-(C=(A=H-(w=(v=e*H)-(v-H)))*(O=j-(F=(v=e*j)-(v-j)))-((B=H*j)-w*F-A*F-w*O))),l[0]=z-(P+_)+(_-C),_=(k=q-((g=q+P)-(_=g-q))+(P-_))-(P=k-B),l[1]=k-(P+_)+(_-B),_=(D=g+P)-g,l[2]=g-(D-_)+(P-_),l[3]=D;const N=r(L,s,4,l,a);_=(z=(A=M-(w=(v=e*M)-(v-M)))*(O=m-(F=(v=e*m)-(v-m)))-((q=M*m)-w*F-A*F-w*O))-(P=z-(C=(A=x-(w=(v=e*x)-(v-x)))*(O=j-(F=(v=e*j)-(v-j)))-((B=x*j)-w*F-A*F-w*O))),l[0]=z-(P+_)+(_-C),_=(k=q-((g=q+P)-(_=g-q))+(P-_))-(P=k-B),l[1]=k-(P+_)+(_-B),_=(D=g+P)-g,l[2]=g-(D-_)+(P-_),l[3]=D;const Q=r(N,a,4,l,d);return d[Q-1]}(t,o,p,b,y,h,m)},t.orient2dfast=function(t,e,n,r,o,f){return(e-f)*(n-o)-(t-o)*(r-f)},Object.defineProperty(t,\"__esModule\",{value:!0})});\n","// index.ts\nimport { featureCollection, multiPolygon, polygon } from \"@turf/helpers\";\nimport { coordEach, geomEach } from \"@turf/meta\";\nfunction polygonSmooth(inputPolys, options) {\n  options = options || {};\n  options.iterations = options.iterations || 1;\n  const { iterations } = options;\n  const outPolys = [];\n  if (!inputPolys) throw new Error(\"inputPolys is required\");\n  geomEach(inputPolys, function(geom, geomIndex, properties) {\n    if (geom.type === \"Polygon\") {\n      let outCoords = [[]];\n      for (let i = 0; i < iterations; i++) {\n        let tempOutput = [];\n        let poly = geom;\n        if (i > 0) {\n          poly = polygon(outCoords).geometry;\n        }\n        processPolygon(poly, tempOutput);\n        outCoords = tempOutput.slice(0);\n      }\n      outPolys.push(polygon(outCoords, properties));\n    } else if (geom.type === \"MultiPolygon\") {\n      let outCoords = [[[]]];\n      for (let y = 0; y < iterations; y++) {\n        let tempOutput = [];\n        let poly = geom;\n        if (y > 0) {\n          poly = multiPolygon(outCoords).geometry;\n        }\n        processMultiPolygon(poly, tempOutput);\n        outCoords = tempOutput.slice(0);\n      }\n      outPolys.push(multiPolygon(outCoords, properties));\n    } else {\n      throw new Error(\"geometry is invalid, must be Polygon or MultiPolygon\");\n    }\n  });\n  return featureCollection(outPolys);\n}\nfunction processPolygon(poly, tempOutput) {\n  var previousCoord;\n  var previousGeometryIndex;\n  coordEach(\n    poly,\n    function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (previousGeometryIndex !== geometryIndex) {\n        tempOutput.push([]);\n      } else {\n        var p0x = previousCoord[0];\n        var p0y = previousCoord[1];\n        var p1x = currentCoord[0];\n        var p1y = currentCoord[1];\n        tempOutput[geometryIndex].push([\n          0.75 * p0x + 0.25 * p1x,\n          0.75 * p0y + 0.25 * p1y\n        ]);\n        tempOutput[geometryIndex].push([\n          0.25 * p0x + 0.75 * p1x,\n          0.25 * p0y + 0.75 * p1y\n        ]);\n      }\n      previousCoord = currentCoord;\n      previousGeometryIndex = geometryIndex;\n    },\n    false\n  );\n  tempOutput.forEach(function(ring) {\n    ring.push(ring[0]);\n  });\n}\nfunction processMultiPolygon(poly, tempOutput) {\n  let previousCoord;\n  let previousMultiFeatureIndex;\n  let previousGeometryIndex;\n  coordEach(\n    poly,\n    function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (previousMultiFeatureIndex !== multiFeatureIndex) {\n        tempOutput.push([[]]);\n      } else if (previousGeometryIndex !== geometryIndex) {\n        tempOutput[multiFeatureIndex].push([]);\n      } else {\n        var p0x = previousCoord[0];\n        var p0y = previousCoord[1];\n        var p1x = currentCoord[0];\n        var p1y = currentCoord[1];\n        tempOutput[multiFeatureIndex][geometryIndex].push([\n          0.75 * p0x + 0.25 * p1x,\n          0.75 * p0y + 0.25 * p1y\n        ]);\n        tempOutput[multiFeatureIndex][geometryIndex].push([\n          0.25 * p0x + 0.75 * p1x,\n          0.25 * p0y + 0.75 * p1y\n        ]);\n      }\n      previousCoord = currentCoord;\n      previousMultiFeatureIndex = multiFeatureIndex;\n      previousGeometryIndex = geometryIndex;\n    },\n    false\n  );\n  tempOutput.forEach(function(poly2) {\n    poly2.forEach(function(ring) {\n      ring.push(ring[0]);\n    });\n  });\n}\nvar turf_polygon_smooth_default = polygonSmooth;\nexport {\n  turf_polygon_smooth_default as default,\n  polygonSmooth\n};\n//# sourceMappingURL=index.js.map","var pointInPolygonFlat = require('./flat.js')\nvar pointInPolygonNested = require('./nested.js')\n\nmodule.exports = function pointInPolygon (point, vs, start, end) {\n    if (vs.length > 0 && Array.isArray(vs[0])) {\n        return pointInPolygonNested(point, vs, start, end);\n    } else {\n        return pointInPolygonFlat(point, vs, start, end);\n    }\n}\nmodule.exports.nested = pointInPolygonNested\nmodule.exports.flat = pointInPolygonFlat\n","// index.ts\nimport { polygon } from \"@turf/helpers\";\nimport { coordEach } from \"@turf/meta\";\nimport concaveman from \"concaveman\";\nfunction convex(geojson, options = {}) {\n  options.concavity = options.concavity || Infinity;\n  const points = [];\n  coordEach(geojson, (coord) => {\n    points.push([coord[0], coord[1]]);\n  });\n  if (!points.length) {\n    return null;\n  }\n  const convexHull = concaveman(points, options.concavity);\n  if (convexHull.length > 3) {\n    return polygon([convexHull]);\n  }\n  return null;\n}\nvar turf_convex_default = convex;\nexport {\n  convex,\n  turf_convex_default as default\n};\n//# sourceMappingURL=index.js.map","!function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(t):(e=\"undefined\"!=typeof globalThis?globalThis:e||self).IndoorEqual=t()}(this,(function(){\"use strict\";function e(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,i=Array(t);r<t;r++)i[r]=e[r];return i}function t(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}function r(e,t){for(var r=0;r<t.length;r++){var i=t[r];i.enumerable=i.enumerable||!1,i.configurable=!0,\"value\"in i&&(i.writable=!0),Object.defineProperty(e,c(i.key),i)}}function i(e,t,i){return t&&r(e.prototype,t),i&&r(e,i),Object.defineProperty(e,\"prototype\",{writable:!1}),e}function n(e,t,r){return(t=c(t))in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,i)}return r}function a(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,i,n=function(e,t){if(null==e)return{};var r={};for(var i in e)if({}.hasOwnProperty.call(e,i)){if(t.includes(i))continue;r[i]=e[i]}return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)r=o[i],t.includes(r)||{}.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}function l(t){return function(t){if(Array.isArray(t))return e(t)}(t)||function(e){if(\"undefined\"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e[\"@@iterator\"])return Array.from(e)}(t)||function(t,r){if(\"string\"==typeof t)return e(t,r);var i={}.toString.call(t).slice(8,-1);return\"Object\"===i&&t.constructor&&(i=t.constructor.name),\"Map\"===i||\"Set\"===i?Array.from(t):\"Arguments\"===i||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)?e(t,r):void 0}(t)||function(){throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}()}function c(e){var t=function(e,t){if(\"object\"!=typeof e||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var i=r.call(e,t);if(\"object\"!=typeof i)return i;throw new TypeError(\"@@toPrimitive must return a primitive value.\")}return String(e)}(e,\"string\");return\"symbol\"==typeof t?t:t+\"\"}function u(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,\"default\")?e.default:e}var h,f={exports:{}};function d(){if(h)return f.exports;function e(e,t=100,r={}){if(\"function\"!=typeof e)throw new TypeError(`Expected the first parameter to be a function, got \\`${typeof e}\\`.`);if(t<0)throw new RangeError(\"`wait` must not be negative.\");const{immediate:i}=\"boolean\"==typeof r?{immediate:r}:r;let n,o,a,s,l;function c(){const t=n,r=o;return n=void 0,o=void 0,l=e.apply(t,r),l}function u(){const e=Date.now()-s;e<t&&e>=0?a=setTimeout(u,t-e):(a=void 0,i||(l=c()))}const h=function(...e){if(n&&this!==n&&Object.getPrototypeOf(this)===Object.getPrototypeOf(n))throw new Error(\"Debounced method called with different contexts of the same prototype.\");n=this,o=e,s=Date.now();const r=i&&!a;return a||(a=setTimeout(u,t)),r&&(l=c()),l};return Object.defineProperty(h,\"isPending\",{get:()=>void 0!==a}),h.clear=()=>{a&&(clearTimeout(a),a=void 0)},h.flush=()=>{a&&h.trigger()},h.trigger=()=>{l=c(),h.clear()},h}return h=1,f.exports.debounce=e,f.exports=e,f.exports}var p,v,y=u(d());var m=u(v?p:(v=1,p=function(e,t){var r=e.length;if(e===t)return!0;if(r!==t.length)return!1;for(var i=0;i<r;i++)if(e[i]!==t[i])return!1;return!0}));var g=function(){return i((function e(r){var i=this;t(this,e),this.indoorequal=r,this._cbRefresh=function(){return i._refresh()},this.indoorequal.on(\"levelschange\",this._cbRefresh),this.indoorequal.on(\"levelchange\",this._cbRefresh),this.$el=document.createElement(\"div\"),this.$el.classList.add(\"maplibregl-ctrl\",\"maplibregl-ctrl-group\",\"maplibregl-ctrl-indoorequal\"),this._refresh()}),[{key:\"destroy\",value:function(){this.$el.remove(),this.indoorequal.off(\"levelschange\",this._cbRefresh),this.indoorequal.off(\"levelchange\",this._cbRefresh)}},{key:\"_refresh\",value:function(){var e=this;this.$el.innerHTML=\"\",this.indoorequal.levels.forEach((function(t){var r=document.createElement(\"button\"),i=document.createElement(\"strong\");i.textContent=t,r.appendChild(i),t==e.indoorequal.level&&r.classList.add(\"maplibregl-ctrl-active\"),r.addEventListener(\"click\",(function(){e.indoorequal.setLevel(t)})),e.$el.appendChild(r)}))}}])}(),b={type:\"symbol\",\"source-layer\":\"poi\",layout:{\"icon-image\":[\"coalesce\",[\"image\",[\"concat\",[\"literal\",\"indoorequal-\"],[\"get\",\"subclass\"]]],[\"image\",[\"concat\",[\"literal\",\"indoorequal-\"],[\"get\",\"class\"]]]],\"text-anchor\":\"top\",\"text-field\":[\"case\",[\"==\",[\"get\",\"class\"],\"aeroway\"],[\"get\",\"ref\"],[\"concat\",[\"get\",\"name:latin\"],\"\\n\",[\"get\",\"name:nonlatin\"]]],\"text-max-width\":9,\"text-offset\":[0,.6],\"text-padding\":2,\"text-size\":12},paint:{\"text-color\":\"#666\",\"text-halo-blur\":.5,\"text-halo-color\":\"#ffffff\",\"text-halo-width\":1}},w=[\"waste_basket\",\"information\",\"vending_machine\",\"bench\",\"photo_booth\",\"ticket_validator\"],_=[{id:\"indoor-polygon\",type:\"fill\",\"source-layer\":\"area\",filter:[\"all\",[\"==\",\"$type\",\"Polygon\"],[\"!=\",\"class\",\"level\"]],paint:{\"fill-color\":[\"case\",[\"all\",[\"has\",\"access\"],[\"in\",[\"get\",\"access\"],[\"literal\",[\"no\",\"private\"]]]],\"#F2F1F0\",[\"any\",[\"all\",[\"==\",[\"get\",\"is_poi\"],!0],[\"!=\",[\"get\",\"class\"],\"corridor\"]],[\"in\",[\"get\",\"subclass\"],[\"literal\",[\"class\",\"laboratory\",\"office\",\"auditorium\",\"amphitheatre\",\"reception\"]]]],\"#D4EDFF\",[\"==\",[\"get\",\"class\"],\"room\"],\"#fefee2\",\"#fdfcfa\"]}},{id:\"indoor-area\",type:\"line\",\"source-layer\":\"area\",filter:[\"all\",[\"in\",\"class\",\"area\",\"corridor\",\"platform\"]],paint:{\"line-color\":\"#bfbfbf\",\"line-width\":1}},{id:\"indoor-column\",type:\"fill\",\"source-layer\":\"area\",filter:[\"all\",[\"==\",\"class\",\"column\"]],paint:{\"fill-color\":\"#bfbfbf\"}},{id:\"indoor-lines\",type:\"line\",\"source-layer\":\"area\",filter:[\"all\",[\"in\",\"class\",\"room\",\"wall\"]],paint:{\"line-color\":\"gray\",\"line-width\":2}},{id:\"indoor-transportation\",type:\"line\",\"source-layer\":\"transportation\",filter:[\"all\"],paint:{\"line-color\":\"gray\",\"line-dasharray\":[.4,.75],\"line-width\":{base:1.4,stops:[[17,2],[20,10]]}}},{id:\"indoor-transportation-poi\",type:\"symbol\",\"source-layer\":\"transportation\",filter:[\"all\",[\"in\",\"$type\",\"Point\",\"LineString\"],[\"in\",\"class\",\"steps\",\"elevator\",\"escalator\"]],layout:{\"icon-image\":[\"case\",[\"has\",\"conveying\"],\"indoorequal-escalator\",[\"concat\",[\"literal\",\"indoorequal-\"],[\"get\",\"class\"]]],\"symbol-placement\":\"line-center\",\"icon-rotation-alignment\":\"viewport\"}},a(a({id:\"indoor-poi-rank1\"},b),{},{filter:[\"all\",[\"==\",\"$type\",\"Point\"],[\"!in\",\"class\"].concat(w)]}),a(a({id:\"indoor-poi-rank2\"},b),{},{minzoom:19,filter:[\"all\",[\"==\",\"$type\",\"Point\"],[\"in\",\"class\"].concat(w)]}),{id:\"indoor-heat\",type:\"heatmap\",\"source-layer\":\"heat\",filter:[\"all\"],paint:{\"heatmap-color\":[\"interpolate\",[\"linear\"],[\"heatmap-density\"],0,\"rgba(102, 103, 173, 0)\",.1,\"rgba(102, 103, 173, 0.2)\",1,\"rgba(102, 103, 173, 0.7)\"],\"heatmap-radius\":[\"interpolate\",[\"linear\"],[\"zoom\"],0,3,13,20,17,40],\"heatmap-intensity\":1,\"heatmap-opacity\":[\"interpolate\",[\"linear\"],[\"zoom\"],16,1,17.1,0]}},{id:\"indoor-name\",type:\"symbol\",\"source-layer\":\"area_name\",filter:[\"all\"],layout:{\"text-field\":[\"concat\",[\"coalesce\",[\"get\",\"name:latin\"],[\"get\",\"ref\"]],\"\\n\",[\"get\",\"name:nonlatin\"]],\"text-max-width\":5,\"text-size\":14},paint:{\"text-color\":\"#666\",\"text-halo-color\":\"#ffffff\",\"text-halo-width\":1}}];function x(e,t,r,i){var n=t.width,o=t.height;if(i){if(i instanceof Uint8ClampedArray)i=new Uint8Array(i.buffer);else if(i.length!==n*o*r)throw new RangeError(\"mismatched image size\")}else i=new Uint8Array(n*o*r);return e.width=n,e.height=o,e.data=i,e}function L(e,t,r,i,n,o){if(0===n.width||0===n.height)return t;if(n.width>e.width||n.height>e.height||r.x>e.width-n.width||r.y>e.height-n.height)throw new RangeError(\"out of range source coordinates for image copy\");if(n.width>t.width||n.height>t.height||i.x>t.width-n.width||i.y>t.height-n.height)throw new RangeError(\"out of range destination coordinates for image copy\");for(var a=e.data,s=t.data,l=0;l<n.height;l++)for(var c=((r.y+l)*e.width+r.x)*o,u=((i.y+l)*t.width+i.x)*o,h=0;h<n.width*o;h++)s[u+h]=a[c+h];return t}var j=function(){function e(r,i){t(this,e),x(this,r,4,i)}return i(e,[{key:\"resize\",value:function(e){!function(e,t,r){var i=t.width,n=t.height;if(i!==e.width||n!==e.height){var o=x({},{width:i,height:n},r);L(e,o,{x:0,y:0},{x:0,y:0},{width:Math.min(e.width,i),height:Math.min(e.height,n)},r),e.width=i,e.height=n,e.data=o.data}}(this,e,4)}},{key:\"replace\",value:function(e,t){t?this.data.set(e):e instanceof Uint8ClampedArray?this.data=new Uint8Array(e.buffer):this.data=e}},{key:\"clone\",value:function(){return new e({width:this.width,height:this.height},new Uint8Array(this.data))}}],[{key:\"copy\",value:function(e,t,r,i,n){L(e,t,r,i,n,4)}}])}();function k(e){var t,r,i=window.devicePixelRatio>1?\"@2x\":\"\",n=fetch(\"\".concat(e).concat(i,\".json\")).then((function(e){return e.json()})).then((function(e){return t=e})),o=fetch(\"\".concat(e).concat(i,\".png\")).then((function(e){return e.blob()})).then((function(e){return(r=new Image).src=URL.createObjectURL(e),new Promise((function(e,t){r.onload=function(){return e()},r.onerror=function(){return t()}}))}));return Promise.all([n,o]).then((function(){var e=function(e){var t=window.document.createElement(\"canvas\"),r=t.getContext(\"2d\");if(!r)throw new Error(\"failed to create canvas 2d context\");return t.width=e.width,t.height=e.height,r.drawImage(e,0,0,e.width,e.height),r.getImageData(0,0,e.width,e.height)}(r),i={};for(var n in t){var o=t[n],a=o.width,s=o.height,l=o.x,c=o.y,u=o.sdf,h=o.pixelRatio,f=o.stretchX,d=o.stretchY,p=o.content,v=new j({width:a,height:s});j.copy(e,v,{x:l,y:c},{x:0,y:0},{width:a,height:s}),i[n]={data:v,pixelRatio:h,sdf:u,stretchX:f,stretchY:d,content:p}}return i}))}var O=[\"data\"],E=function(){return i((function e(r){var i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t(this,e);var n=a(a({},{layers:_,geojson:{}}),i);this.map=r,this.geojson=n.geojson,this.layers=n.layers,this.baseSourceId=\"indoorequal\",this.sourceId=\"\".concat(this.baseSourceId,\"_area\")}),[{key:\"addSource\",value:function(){var e=this;Object.keys(this.geojson).forEach((function(t){e.map.addSource(\"\".concat(e.baseSourceId,\"_\").concat(t),{type:\"geojson\",data:e.geojson[t]})}))}},{key:\"addLayers\",value:function(){var e=this,t=Object.keys(this.geojson),r=this.layers;this.layers=r.filter((function(e){return t.includes(e[\"source-layer\"])})),this.layers.forEach((function(t){e.map.addLayer(a(a({source:\"\".concat(e.baseSourceId,\"_\").concat(t[\"source-layer\"])},t),{},{\"source-layer\":\"\"}))}))}},{key:\"remove\",value:function(){var e=this;this.layers.forEach((function(t){e.map.removeLayer(t.id)})),Object.keys(this.geojson).forEach((function(t){e.map.removeSource(\"\".concat(e.baseSourceId,\"_\").concat(t))}))}}])}(),P=function(){return i((function e(r){var i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t(this,e);var n={url:\"https://tiles.indoorequal.org/\",layers:_},o=a(a({},n),i);if(o.url===n.url&&!o.apiKey)throw\"You must register your apiKey at https://indoorequal.com before and set it as apiKey param.\";this.map=r,this.url=o.url,this.apiKey=o.apiKey,this.layers=o.layers,this.sourceId=\"indoorequal\"}),[{key:\"addSource\",value:function(){var e=this.apiKey?\"?key=\".concat(this.apiKey):\"\";this.map.addSource(this.sourceId,{type:\"vector\",url:\"\".concat(this.url).concat(e)})}},{key:\"addLayers\",value:function(){var e=this;this.layers.forEach((function(t){e.map.addLayer(a({source:e.sourceId},t))}))}},{key:\"remove\",value:function(){var e=this;this.layers.forEach((function(t){e.map.removeLayer(t.id)})),this.map.removeSource(this.sourceId)}}])}(),S=function(){return i((function e(r){var i=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t(this,e);var o=n.geojson?E:P,s=a(a({},{heatmap:!0}),n);this.source=new o(r,n),this.map=r,this.levels=[],this.level=\"0\",this.events={},this.map.isStyleLoaded()?(this._init(),this.setHeatmapVisible(s.heatmap)):this.map.once(\"load\",(function(){i._init(),i.setHeatmapVisible(s.heatmap)}))}),[{key:\"remove\",value:function(e){e||this.source.remove(),this._updateLevelsDebounce.clear(),this.map.off(\"load\",this._updateLevelsDebounce),this.map.off(\"data\",this._updateLevelsDebounce),this.map.off(\"move\",this._updateLevelsDebounce),this._control&&this.onRemove()}},{key:\"on\",value:function(e,t){this.events[e]||(this.events[e]=[]),this.events[e].push(t)}},{key:\"off\",value:function(e,t){this.events[e]||(this.events[e]=[]),this.events[e]=this.events[e].filter((function(e){return e!==t}))}},{key:\"onAdd\",value:function(){return this._control=new g(this),this._control.$el}},{key:\"onRemove\",value:function(){this._control.destroy(),this._control=null}},{key:\"setLevel\",value:function(e){this.level=e,this._updateFilters(),this._emitLevelChange()}},{key:\"updateLevel\",value:function(e){console.log(\"The updateLevel method is deprecated. Please use setLevel instead.\"),this.setLevel(e)}},{key:\"loadSprite\",value:function(e){var t=this,r=a({update:!1},arguments.length>1&&void 0!==arguments[1]?arguments[1]:{});return k(e).then((function(e){for(var i in e){var n=e[i],o=n.data,a=s(n,O);t.map.hasImage(i)?r.update&&t.map.updateImage(i,o):t.map.addImage(i,o,a)}return e}))}},{key:\"setHeatmapVisible\",value:function(e){this.map.getLayer(\"indoor-heat\")&&this.map.setLayoutProperty(\"indoor-heat\",\"visibility\",e?\"visible\":\"none\")}},{key:\"_init\",value:function(){var e=this;this.source.addSource(),this.source.addLayers(),this._updateFilters(),this._updateLevelsDebounce=y(this._updateLevels.bind(this),1e3),this.map.on(\"load\",this._updateLevelsDebounce),this.map.on(\"data\",this._updateLevelsDebounce),this.map.on(\"move\",this._updateLevelsDebounce),this.map.on(\"remove\",(function(){e.remove(!0)}))}},{key:\"_updateFilters\",value:function(){var e=this;this.source.layers.filter((function(e){return\"heatmap\"!==e.type})).forEach((function(t){e.map.setFilter(t.id,[].concat(l(t.filter||[\"all\"]),[[\"==\",\"level\",e.level]]))}))}},{key:\"_refreshAfterLevelsUpdate\",value:function(){this.levels.includes(this.level)||this.setLevel(\"0\")}},{key:\"_updateLevels\",value:function(){if(this.map.isSourceLoaded(this.source.sourceId)){var e=function(e){for(var t=[],r=0;r<e.length;r++){var i=e[r];if(\"level\"!==i.properties.class){var n=i.properties.level;t.includes(n)||t.push(n)}}return t.sort((function(e,t){return e-t})).reverse()}(this.map.querySourceFeatures(this.source.sourceId,{sourceLayer:\"area\"}));m(e,this.levels)||(this.levels=e,this._emitLevelsChange(),this._refreshAfterLevelsUpdate())}}},{key:\"_emitLevelsChange\",value:function(){this._emitEvent(\"levelschange\",this.levels)}},{key:\"_emitLevelChange\",value:function(){this._emitEvent(\"levelchange\",this.level)}},{key:\"_emitEvent\",value:function(e){for(var t=arguments.length,r=new Array(t>1?t-1:0),i=1;i<t;i++)r[i-1]=arguments[i];(this.events[e]||[]).forEach((function(e){return e.apply(void 0,r)}))}}])}();return S}));\n//# sourceMappingURL=maplibre-gl-indoorequal.umd.min.js.map\n","module.exports = function pointInPolygonFlat (point, vs, start, end) {\n    var x = point[0], y = point[1];\n    var inside = false;\n    if (start === undefined) start = 0;\n    if (end === undefined) end = vs.length;\n    var len = (end-start)/2;\n    for (var i = 0, j = len - 1; i < len; j = i++) {\n        var xi = vs[start+i*2+0], yi = vs[start+i*2+1];\n        var xj = vs[start+j*2+0], yj = vs[start+j*2+1];\n        var intersect = ((yi > y) !== (yj > y))\n            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n        if (intersect) inside = !inside;\n    }\n    return inside;\n};\n","// index.ts\nimport { coordEach } from \"@turf/meta\";\nfunction bbox(geojson, options = {}) {\n  if (geojson.bbox != null && true !== options.recompute) {\n    return geojson.bbox;\n  }\n  const result = [Infinity, Infinity, -Infinity, -Infinity];\n  coordEach(geojson, (coord) => {\n    if (result[0] > coord[0]) {\n      result[0] = coord[0];\n    }\n    if (result[1] > coord[1]) {\n      result[1] = coord[1];\n    }\n    if (result[2] < coord[0]) {\n      result[2] = coord[0];\n    }\n    if (result[3] < coord[1]) {\n      result[3] = coord[1];\n    }\n  });\n  return result;\n}\nvar turf_bbox_default = bbox;\nexport {\n  bbox,\n  turf_bbox_default as default\n};\n//# sourceMappingURL=index.js.map","// index.ts\nimport { bbox } from \"@turf/bbox\";\nimport { point } from \"@turf/helpers\";\nfunction center(geojson, options = {}) {\n  const ext = bbox(geojson);\n  const x = (ext[0] + ext[2]) / 2;\n  const y = (ext[1] + ext[3]) / 2;\n  return point([x, y], options.properties, options);\n}\nvar turf_center_default = center;\nexport {\n  center,\n  turf_center_default as default\n};\n//# sourceMappingURL=index.js.map","// Adds floating point numbers with twice the normal precision.\n// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and\n// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)\n// 305363 (1997).\n// Code adapted from GeographicLib by Charles F. F. Karney,\n// http://geographiclib.sourceforge.net/\n\nexport default function() {\n  return new Adder;\n}\n\nfunction Adder() {\n  this.reset();\n}\n\nAdder.prototype = {\n  constructor: Adder,\n  reset: function() {\n    this.s = // rounded value\n    this.t = 0; // exact error\n  },\n  add: function(y) {\n    add(temp, y, this.t);\n    add(this, temp.s, this.s);\n    if (this.s) this.t += temp.t;\n    else this.s = temp.t;\n  },\n  valueOf: function() {\n    return this.s;\n  }\n};\n\nvar temp = new Adder;\n\nfunction add(adder, a, b) {\n  var x = adder.s = a + b,\n      bv = x - a,\n      av = x - bv;\n  adder.t = (a - av) + (b - bv);\n}\n","export var epsilon = 1e-6;\nexport var epsilon2 = 1e-12;\nexport var pi = Math.PI;\nexport var halfPi = pi / 2;\nexport var quarterPi = pi / 4;\nexport var tau = pi * 2;\n\nexport var degrees = 180 / pi;\nexport var radians = pi / 180;\n\nexport var abs = Math.abs;\nexport var atan = Math.atan;\nexport var atan2 = Math.atan2;\nexport var cos = Math.cos;\nexport var ceil = Math.ceil;\nexport var exp = Math.exp;\nexport var floor = Math.floor;\nexport var log = Math.log;\nexport var pow = Math.pow;\nexport var sin = Math.sin;\nexport var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };\nexport var sqrt = Math.sqrt;\nexport var tan = Math.tan;\n\nexport function acos(x) {\n  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);\n}\n\nexport function asin(x) {\n  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);\n}\n\nexport function haversin(x) {\n  return (x = sin(x / 2)) * x;\n}\n","export default function noop() {}\n","function streamGeometry(geometry, stream) {\n  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {\n    streamGeometryType[geometry.type](geometry, stream);\n  }\n}\n\nvar streamObjectType = {\n  Feature: function(object, stream) {\n    streamGeometry(object.geometry, stream);\n  },\n  FeatureCollection: function(object, stream) {\n    var features = object.features, i = -1, n = features.length;\n    while (++i < n) streamGeometry(features[i].geometry, stream);\n  }\n};\n\nvar streamGeometryType = {\n  Sphere: function(object, stream) {\n    stream.sphere();\n  },\n  Point: function(object, stream) {\n    object = object.coordinates;\n    stream.point(object[0], object[1], object[2]);\n  },\n  MultiPoint: function(object, stream) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);\n  },\n  LineString: function(object, stream) {\n    streamLine(object.coordinates, stream, 0);\n  },\n  MultiLineString: function(object, stream) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) streamLine(coordinates[i], stream, 0);\n  },\n  Polygon: function(object, stream) {\n    streamPolygon(object.coordinates, stream);\n  },\n  MultiPolygon: function(object, stream) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) streamPolygon(coordinates[i], stream);\n  },\n  GeometryCollection: function(object, stream) {\n    var geometries = object.geometries, i = -1, n = geometries.length;\n    while (++i < n) streamGeometry(geometries[i], stream);\n  }\n};\n\nfunction streamLine(coordinates, stream, closed) {\n  var i = -1, n = coordinates.length - closed, coordinate;\n  stream.lineStart();\n  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);\n  stream.lineEnd();\n}\n\nfunction streamPolygon(coordinates, stream) {\n  var i = -1, n = coordinates.length;\n  stream.polygonStart();\n  while (++i < n) streamLine(coordinates[i], stream, 1);\n  stream.polygonEnd();\n}\n\nexport default function(object, stream) {\n  if (object && streamObjectType.hasOwnProperty(object.type)) {\n    streamObjectType[object.type](object, stream);\n  } else {\n    streamGeometry(object, stream);\n  }\n}\n","import adder from \"./adder\";\nimport {atan2, cos, quarterPi, radians, sin, tau} from \"./math\";\nimport noop from \"./noop\";\nimport stream from \"./stream\";\n\nexport var areaRingSum = adder();\n\nvar areaSum = adder(),\n    lambda00,\n    phi00,\n    lambda0,\n    cosPhi0,\n    sinPhi0;\n\nexport var areaStream = {\n  point: noop,\n  lineStart: noop,\n  lineEnd: noop,\n  polygonStart: function() {\n    areaRingSum.reset();\n    areaStream.lineStart = areaRingStart;\n    areaStream.lineEnd = areaRingEnd;\n  },\n  polygonEnd: function() {\n    var areaRing = +areaRingSum;\n    areaSum.add(areaRing < 0 ? tau + areaRing : areaRing);\n    this.lineStart = this.lineEnd = this.point = noop;\n  },\n  sphere: function() {\n    areaSum.add(tau);\n  }\n};\n\nfunction areaRingStart() {\n  areaStream.point = areaPointFirst;\n}\n\nfunction areaRingEnd() {\n  areaPoint(lambda00, phi00);\n}\n\nfunction areaPointFirst(lambda, phi) {\n  areaStream.point = areaPoint;\n  lambda00 = lambda, phi00 = phi;\n  lambda *= radians, phi *= radians;\n  lambda0 = lambda, cosPhi0 = cos(phi = phi / 2 + quarterPi), sinPhi0 = sin(phi);\n}\n\nfunction areaPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  phi = phi / 2 + quarterPi; // half the angular distance from south pole\n\n  // Spherical excess E for a spherical triangle with vertices: south pole,\n  // previous point, current point.  Uses a formula derived from Cagnolis\n  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).\n  var dLambda = lambda - lambda0,\n      sdLambda = dLambda >= 0 ? 1 : -1,\n      adLambda = sdLambda * dLambda,\n      cosPhi = cos(phi),\n      sinPhi = sin(phi),\n      k = sinPhi0 * sinPhi,\n      u = cosPhi0 * cosPhi + k * cos(adLambda),\n      v = k * sdLambda * sin(adLambda);\n  areaRingSum.add(atan2(v, u));\n\n  // Advance the previous points.\n  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;\n}\n\nexport default function(object) {\n  areaSum.reset();\n  stream(object, areaStream);\n  return areaSum * 2;\n}\n","import {asin, atan2, cos, sin, sqrt} from \"./math\";\n\nexport function spherical(cartesian) {\n  return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];\n}\n\nexport function cartesian(spherical) {\n  var lambda = spherical[0], phi = spherical[1], cosPhi = cos(phi);\n  return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];\n}\n\nexport function cartesianDot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n\nexport function cartesianCross(a, b) {\n  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n}\n\n// TODO return a\nexport function cartesianAddInPlace(a, b) {\n  a[0] += b[0], a[1] += b[1], a[2] += b[2];\n}\n\nexport function cartesianScale(vector, k) {\n  return [vector[0] * k, vector[1] * k, vector[2] * k];\n}\n\n// TODO return d\nexport function cartesianNormalizeInPlace(d) {\n  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n  d[0] /= l, d[1] /= l, d[2] /= l;\n}\n","import adder from \"./adder\";\nimport {areaStream, areaRingSum} from \"./area\";\nimport {cartesian, cartesianCross, cartesianNormalizeInPlace, spherical} from \"./cartesian\";\nimport {abs, degrees, epsilon, radians} from \"./math\";\nimport stream from \"./stream\";\n\nvar lambda0, phi0, lambda1, phi1, // bounds\n    lambda2, // previous lambda-coordinate\n    lambda00, phi00, // first point\n    p0, // previous 3D point\n    deltaSum = adder(),\n    ranges,\n    range;\n\nvar boundsStream = {\n  point: boundsPoint,\n  lineStart: boundsLineStart,\n  lineEnd: boundsLineEnd,\n  polygonStart: function() {\n    boundsStream.point = boundsRingPoint;\n    boundsStream.lineStart = boundsRingStart;\n    boundsStream.lineEnd = boundsRingEnd;\n    deltaSum.reset();\n    areaStream.polygonStart();\n  },\n  polygonEnd: function() {\n    areaStream.polygonEnd();\n    boundsStream.point = boundsPoint;\n    boundsStream.lineStart = boundsLineStart;\n    boundsStream.lineEnd = boundsLineEnd;\n    if (areaRingSum < 0) lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n    else if (deltaSum > epsilon) phi1 = 90;\n    else if (deltaSum < -epsilon) phi0 = -90;\n    range[0] = lambda0, range[1] = lambda1;\n  }\n};\n\nfunction boundsPoint(lambda, phi) {\n  ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n}\n\nfunction linePoint(lambda, phi) {\n  var p = cartesian([lambda * radians, phi * radians]);\n  if (p0) {\n    var normal = cartesianCross(p0, p),\n        equatorial = [normal[1], -normal[0], 0],\n        inflection = cartesianCross(equatorial, normal);\n    cartesianNormalizeInPlace(inflection);\n    inflection = spherical(inflection);\n    var delta = lambda - lambda2,\n        sign = delta > 0 ? 1 : -1,\n        lambdai = inflection[0] * degrees * sign,\n        phii,\n        antimeridian = abs(delta) > 180;\n    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n      phii = inflection[1] * degrees;\n      if (phii > phi1) phi1 = phii;\n    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n      phii = -inflection[1] * degrees;\n      if (phii < phi0) phi0 = phii;\n    } else {\n      if (phi < phi0) phi0 = phi;\n      if (phi > phi1) phi1 = phi;\n    }\n    if (antimeridian) {\n      if (lambda < lambda2) {\n        if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;\n      } else {\n        if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;\n      }\n    } else {\n      if (lambda1 >= lambda0) {\n        if (lambda < lambda0) lambda0 = lambda;\n        if (lambda > lambda1) lambda1 = lambda;\n      } else {\n        if (lambda > lambda2) {\n          if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;\n        } else {\n          if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;\n        }\n      }\n    }\n  } else {\n    ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);\n  }\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n  p0 = p, lambda2 = lambda;\n}\n\nfunction boundsLineStart() {\n  boundsStream.point = linePoint;\n}\n\nfunction boundsLineEnd() {\n  range[0] = lambda0, range[1] = lambda1;\n  boundsStream.point = boundsPoint;\n  p0 = null;\n}\n\nfunction boundsRingPoint(lambda, phi) {\n  if (p0) {\n    var delta = lambda - lambda2;\n    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);\n  } else {\n    lambda00 = lambda, phi00 = phi;\n  }\n  areaStream.point(lambda, phi);\n  linePoint(lambda, phi);\n}\n\nfunction boundsRingStart() {\n  areaStream.lineStart();\n}\n\nfunction boundsRingEnd() {\n  boundsRingPoint(lambda00, phi00);\n  areaStream.lineEnd();\n  if (abs(deltaSum) > epsilon) lambda0 = -(lambda1 = 180);\n  range[0] = lambda0, range[1] = lambda1;\n  p0 = null;\n}\n\n// Finds the left-right distance between two longitudes.\n// This is almost the same as (lambda1 - lambda0 + 360) % 360, except that we want\n// the distance between 180 to be 360.\nfunction angle(lambda0, lambda1) {\n  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;\n}\n\nfunction rangeCompare(a, b) {\n  return a[0] - b[0];\n}\n\nfunction rangeContains(range, x) {\n  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;\n}\n\nexport default function(feature) {\n  var i, n, a, b, merged, deltaMax, delta;\n\n  phi1 = lambda1 = -(lambda0 = phi0 = Infinity);\n  ranges = [];\n  stream(feature, boundsStream);\n\n  // First, sort ranges by their minimum longitudes.\n  if (n = ranges.length) {\n    ranges.sort(rangeCompare);\n\n    // Then, merge any ranges that overlap.\n    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {\n      b = ranges[i];\n      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {\n        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];\n        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];\n      } else {\n        merged.push(a = b);\n      }\n    }\n\n    // Finally, find the largest gap between the merged ranges.\n    // The final bounding box will be the inverse of this gap.\n    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {\n      b = merged[i];\n      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0 = b[0], lambda1 = a[1];\n    }\n  }\n\n  ranges = range = null;\n\n  return lambda0 === Infinity || phi0 === Infinity\n      ? [[NaN, NaN], [NaN, NaN]]\n      : [[lambda0, phi0], [lambda1, phi1]];\n}\n","import {asin, atan2, cos, degrees, epsilon, epsilon2, radians, sin, sqrt} from \"./math\";\nimport noop from \"./noop\";\nimport stream from \"./stream\";\n\nvar W0, W1,\n    X0, Y0, Z0,\n    X1, Y1, Z1,\n    X2, Y2, Z2,\n    lambda00, phi00, // first point\n    x0, y0, z0; // previous point\n\nvar centroidStream = {\n  sphere: noop,\n  point: centroidPoint,\n  lineStart: centroidLineStart,\n  lineEnd: centroidLineEnd,\n  polygonStart: function() {\n    centroidStream.lineStart = centroidRingStart;\n    centroidStream.lineEnd = centroidRingEnd;\n  },\n  polygonEnd: function() {\n    centroidStream.lineStart = centroidLineStart;\n    centroidStream.lineEnd = centroidLineEnd;\n  }\n};\n\n// Arithmetic mean of Cartesian vectors.\nfunction centroidPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi);\n  centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));\n}\n\nfunction centroidPointCartesian(x, y, z) {\n  ++W0;\n  X0 += (x - X0) / W0;\n  Y0 += (y - Y0) / W0;\n  Z0 += (z - Z0) / W0;\n}\n\nfunction centroidLineStart() {\n  centroidStream.point = centroidLinePointFirst;\n}\n\nfunction centroidLinePointFirst(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi);\n  x0 = cosPhi * cos(lambda);\n  y0 = cosPhi * sin(lambda);\n  z0 = sin(phi);\n  centroidStream.point = centroidLinePoint;\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroidLinePoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi),\n      x = cosPhi * cos(lambda),\n      y = cosPhi * sin(lambda),\n      z = sin(phi),\n      w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);\n  W1 += w;\n  X1 += w * (x0 + (x0 = x));\n  Y1 += w * (y0 + (y0 = y));\n  Z1 += w * (z0 + (z0 = z));\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroidLineEnd() {\n  centroidStream.point = centroidPoint;\n}\n\n// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,\n// J. Applied Mechanics 42, 239 (1975).\nfunction centroidRingStart() {\n  centroidStream.point = centroidRingPointFirst;\n}\n\nfunction centroidRingEnd() {\n  centroidRingPoint(lambda00, phi00);\n  centroidStream.point = centroidPoint;\n}\n\nfunction centroidRingPointFirst(lambda, phi) {\n  lambda00 = lambda, phi00 = phi;\n  lambda *= radians, phi *= radians;\n  centroidStream.point = centroidRingPoint;\n  var cosPhi = cos(phi);\n  x0 = cosPhi * cos(lambda);\n  y0 = cosPhi * sin(lambda);\n  z0 = sin(phi);\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroidRingPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi),\n      x = cosPhi * cos(lambda),\n      y = cosPhi * sin(lambda),\n      z = sin(phi),\n      cx = y0 * z - z0 * y,\n      cy = z0 * x - x0 * z,\n      cz = x0 * y - y0 * x,\n      m = sqrt(cx * cx + cy * cy + cz * cz),\n      w = asin(m), // line weight = angle\n      v = m && -w / m; // area weight multiplier\n  X2 += v * cx;\n  Y2 += v * cy;\n  Z2 += v * cz;\n  W1 += w;\n  X1 += w * (x0 + (x0 = x));\n  Y1 += w * (y0 + (y0 = y));\n  Z1 += w * (z0 + (z0 = z));\n  centroidPointCartesian(x0, y0, z0);\n}\n\nexport default function(object) {\n  W0 = W1 =\n  X0 = Y0 = Z0 =\n  X1 = Y1 = Z1 =\n  X2 = Y2 = Z2 = 0;\n  stream(object, centroidStream);\n\n  var x = X2,\n      y = Y2,\n      z = Z2,\n      m = x * x + y * y + z * z;\n\n  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.\n  if (m < epsilon2) {\n    x = X1, y = Y1, z = Z1;\n    // If the feature has zero length, fall back to arithmetic mean of point vectors.\n    if (W1 < epsilon) x = X0, y = Y0, z = Z0;\n    m = x * x + y * y + z * z;\n    // If the feature still has an undefined ccentroid, then return.\n    if (m < epsilon2) return [NaN, NaN];\n  }\n\n  return [atan2(y, x) * degrees, asin(z / sqrt(m)) * degrees];\n}\n","export default function(a, b) {\n\n  function compose(x, y) {\n    return x = a(x, y), b(x[0], x[1]);\n  }\n\n  if (a.invert && b.invert) compose.invert = function(x, y) {\n    return x = b.invert(x, y), x && a.invert(x[0], x[1]);\n  };\n\n  return compose;\n}\n","import compose from \"./compose\";\nimport {asin, atan2, cos, degrees, pi, radians, sin, tau} from \"./math\";\n\nfunction rotationIdentity(lambda, phi) {\n  return [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];\n}\n\nrotationIdentity.invert = rotationIdentity;\n\nexport function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {\n  return (deltaLambda %= tau) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))\n    : rotationLambda(deltaLambda))\n    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)\n    : rotationIdentity);\n}\n\nfunction forwardRotationLambda(deltaLambda) {\n  return function(lambda, phi) {\n    return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];\n  };\n}\n\nfunction rotationLambda(deltaLambda) {\n  var rotation = forwardRotationLambda(deltaLambda);\n  rotation.invert = forwardRotationLambda(-deltaLambda);\n  return rotation;\n}\n\nfunction rotationPhiGamma(deltaPhi, deltaGamma) {\n  var cosDeltaPhi = cos(deltaPhi),\n      sinDeltaPhi = sin(deltaPhi),\n      cosDeltaGamma = cos(deltaGamma),\n      sinDeltaGamma = sin(deltaGamma);\n\n  function rotation(lambda, phi) {\n    var cosPhi = cos(phi),\n        x = cos(lambda) * cosPhi,\n        y = sin(lambda) * cosPhi,\n        z = sin(phi),\n        k = z * cosDeltaPhi + x * sinDeltaPhi;\n    return [\n      atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),\n      asin(k * cosDeltaGamma + y * sinDeltaGamma)\n    ];\n  }\n\n  rotation.invert = function(lambda, phi) {\n    var cosPhi = cos(phi),\n        x = cos(lambda) * cosPhi,\n        y = sin(lambda) * cosPhi,\n        z = sin(phi),\n        k = z * cosDeltaGamma - y * sinDeltaGamma;\n    return [\n      atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),\n      asin(k * cosDeltaPhi - x * sinDeltaPhi)\n    ];\n  };\n\n  return rotation;\n}\n\nexport default function(rotate) {\n  rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);\n\n  function forward(coordinates) {\n    coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);\n    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;\n  }\n\n  forward.invert = function(coordinates) {\n    coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);\n    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;\n  };\n\n  return forward;\n}\n","import {cartesian, cartesianNormalizeInPlace, spherical} from \"./cartesian\";\nimport constant from \"./constant\";\nimport {acos, cos, degrees, epsilon, radians, sin, tau} from \"./math\";\nimport {rotateRadians} from \"./rotation\";\n\n// Generates a circle centered at [0, 0], with a given radius and precision.\nexport function circleStream(stream, radius, delta, direction, t0, t1) {\n  if (!delta) return;\n  var cosRadius = cos(radius),\n      sinRadius = sin(radius),\n      step = direction * delta;\n  if (t0 == null) {\n    t0 = radius + direction * tau;\n    t1 = radius - step / 2;\n  } else {\n    t0 = circleRadius(cosRadius, t0);\n    t1 = circleRadius(cosRadius, t1);\n    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau;\n  }\n  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {\n    point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);\n    stream.point(point[0], point[1]);\n  }\n}\n\n// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].\nfunction circleRadius(cosRadius, point) {\n  point = cartesian(point), point[0] -= cosRadius;\n  cartesianNormalizeInPlace(point);\n  var radius = acos(-point[1]);\n  return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;\n}\n\nexport default function() {\n  var center = constant([0, 0]),\n      radius = constant(90),\n      precision = constant(6),\n      ring,\n      rotate,\n      stream = {point: point};\n\n  function point(x, y) {\n    ring.push(x = rotate(x, y));\n    x[0] *= degrees, x[1] *= degrees;\n  }\n\n  function circle() {\n    var c = center.apply(this, arguments),\n        r = radius.apply(this, arguments) * radians,\n        p = precision.apply(this, arguments) * radians;\n    ring = [];\n    rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;\n    circleStream(stream, r, p, 1);\n    c = {type: \"Polygon\", coordinates: [ring]};\n    ring = rotate = null;\n    return c;\n  }\n\n  circle.center = function(_) {\n    return arguments.length ? (center = typeof _ === \"function\" ? _ : constant([+_[0], +_[1]]), circle) : center;\n  };\n\n  circle.radius = function(_) {\n    return arguments.length ? (radius = typeof _ === \"function\" ? _ : constant(+_), circle) : radius;\n  };\n\n  circle.precision = function(_) {\n    return arguments.length ? (precision = typeof _ === \"function\" ? _ : constant(+_), circle) : precision;\n  };\n\n  return circle;\n}\n","import noop from \"../noop\";\n\nexport default function() {\n  var lines = [],\n      line;\n  return {\n    point: function(x, y) {\n      line.push([x, y]);\n    },\n    lineStart: function() {\n      lines.push(line = []);\n    },\n    lineEnd: noop,\n    rejoin: function() {\n      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));\n    },\n    result: function() {\n      var result = lines;\n      lines = [];\n      line = null;\n      return result;\n    }\n  };\n}\n","export default function(a, b, x0, y0, x1, y1) {\n  var ax = a[0],\n      ay = a[1],\n      bx = b[0],\n      by = b[1],\n      t0 = 0,\n      t1 = 1,\n      dx = bx - ax,\n      dy = by - ay,\n      r;\n\n  r = x0 - ax;\n  if (!dx && r > 0) return;\n  r /= dx;\n  if (dx < 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  } else if (dx > 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  }\n\n  r = x1 - ax;\n  if (!dx && r < 0) return;\n  r /= dx;\n  if (dx < 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  } else if (dx > 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  }\n\n  r = y0 - ay;\n  if (!dy && r > 0) return;\n  r /= dy;\n  if (dy < 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  } else if (dy > 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  }\n\n  r = y1 - ay;\n  if (!dy && r < 0) return;\n  r /= dy;\n  if (dy < 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  } else if (dy > 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  }\n\n  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;\n  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;\n  return true;\n}\n","import {abs, epsilon} from \"./math\";\n\nexport default function(a, b) {\n  return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;\n}\n","import pointEqual from \"../pointEqual\";\n\nfunction Intersection(point, points, other, entry) {\n  this.x = point;\n  this.z = points;\n  this.o = other; // another intersection\n  this.e = entry; // is an entry?\n  this.v = false; // visited\n  this.n = this.p = null; // next & previous\n}\n\n// A generalized polygon clipping algorithm: given a polygon that has been cut\n// into its visible line segments, and rejoins the segments by interpolating\n// along the clip edge.\nexport default function(segments, compareIntersection, startInside, interpolate, stream) {\n  var subject = [],\n      clip = [],\n      i,\n      n;\n\n  segments.forEach(function(segment) {\n    if ((n = segment.length - 1) <= 0) return;\n    var n, p0 = segment[0], p1 = segment[n], x;\n\n    // If the first and last points of a segment are coincident, then treat as a\n    // closed ring. TODO if all rings are closed, then the winding order of the\n    // exterior ring should be checked.\n    if (pointEqual(p0, p1)) {\n      stream.lineStart();\n      for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);\n      stream.lineEnd();\n      return;\n    }\n\n    subject.push(x = new Intersection(p0, segment, null, true));\n    clip.push(x.o = new Intersection(p0, null, x, false));\n    subject.push(x = new Intersection(p1, segment, null, false));\n    clip.push(x.o = new Intersection(p1, null, x, true));\n  });\n\n  if (!subject.length) return;\n\n  clip.sort(compareIntersection);\n  link(subject);\n  link(clip);\n\n  for (i = 0, n = clip.length; i < n; ++i) {\n    clip[i].e = startInside = !startInside;\n  }\n\n  var start = subject[0],\n      points,\n      point;\n\n  while (1) {\n    // Find first unvisited intersection.\n    var current = start,\n        isSubject = true;\n    while (current.v) if ((current = current.n) === start) return;\n    points = current.z;\n    stream.lineStart();\n    do {\n      current.v = current.o.v = true;\n      if (current.e) {\n        if (isSubject) {\n          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);\n        } else {\n          interpolate(current.x, current.n.x, 1, stream);\n        }\n        current = current.n;\n      } else {\n        if (isSubject) {\n          points = current.p.z;\n          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);\n        } else {\n          interpolate(current.x, current.p.x, -1, stream);\n        }\n        current = current.p;\n      }\n      current = current.o;\n      points = current.z;\n      isSubject = !isSubject;\n    } while (!current.v);\n    stream.lineEnd();\n  }\n}\n\nfunction link(array) {\n  if (!(n = array.length)) return;\n  var n,\n      i = 0,\n      a = array[0],\n      b;\n  while (++i < n) {\n    a.n = b = array[i];\n    b.p = a;\n    a = b;\n  }\n  a.n = b = array[0];\n  b.p = a;\n}\n","export default function(a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n","import ascending from \"./ascending\";\n\nexport default function(compare) {\n  if (compare.length === 1) compare = ascendingComparator(compare);\n  return {\n    left: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      }\n      return lo;\n    },\n    right: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) > 0) hi = mid;\n        else lo = mid + 1;\n      }\n      return lo;\n    }\n  };\n}\n\nfunction ascendingComparator(f) {\n  return function(d, x) {\n    return ascending(f(d), x);\n  };\n}\n","import ascending from \"./ascending\";\nimport bisector from \"./bisector\";\n\nvar ascendingBisect = bisector(ascending);\nexport var bisectRight = ascendingBisect.right;\nexport var bisectLeft = ascendingBisect.left;\nexport default bisectRight;\n","var array = Array.prototype;\n\nexport var slice = array.slice;\nexport var map = array.map;\n","var e10 = Math.sqrt(50),\n    e5 = Math.sqrt(10),\n    e2 = Math.sqrt(2);\n\nexport default function(start, stop, count) {\n  var reverse,\n      i = -1,\n      n,\n      ticks,\n      step;\n\n  stop = +stop, start = +start, count = +count;\n  if (start === stop && count > 0) return [start];\n  if (reverse = stop < start) n = start, start = stop, stop = n;\n  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];\n\n  if (step > 0) {\n    start = Math.ceil(start / step);\n    stop = Math.floor(stop / step);\n    ticks = new Array(n = Math.ceil(stop - start + 1));\n    while (++i < n) ticks[i] = (start + i) * step;\n  } else {\n    start = Math.floor(start * step);\n    stop = Math.ceil(stop * step);\n    ticks = new Array(n = Math.ceil(start - stop + 1));\n    while (++i < n) ticks[i] = (start - i) / step;\n  }\n\n  if (reverse) ticks.reverse();\n\n  return ticks;\n}\n\nexport function tickIncrement(start, stop, count) {\n  var step = (stop - start) / Math.max(0, count),\n      power = Math.floor(Math.log(step) / Math.LN10),\n      error = step / Math.pow(10, power);\n  return power >= 0\n      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)\n      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);\n}\n\nexport function tickStep(start, stop, count) {\n  var step0 = Math.abs(stop - start) / Math.max(0, count),\n      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),\n      error = step0 / step1;\n  if (error >= e10) step1 *= 10;\n  else if (error >= e5) step1 *= 5;\n  else if (error >= e2) step1 *= 2;\n  return stop < start ? -step1 : step1;\n}\n","import {slice} from \"./array\";\nimport bisect from \"./bisect\";\nimport constant from \"./constant\";\nimport extent from \"./extent\";\nimport identity from \"./identity\";\nimport range from \"./range\";\nimport {tickStep} from \"./ticks\";\nimport sturges from \"./threshold/sturges\";\n\nexport default function() {\n  var value = identity,\n      domain = extent,\n      threshold = sturges;\n\n  function histogram(data) {\n    var i,\n        n = data.length,\n        x,\n        values = new Array(n);\n\n    for (i = 0; i < n; ++i) {\n      values[i] = value(data[i], i, data);\n    }\n\n    var xz = domain(values),\n        x0 = xz[0],\n        x1 = xz[1],\n        tz = threshold(values, x0, x1);\n\n    // Convert number of thresholds into uniform thresholds.\n    if (!Array.isArray(tz)) {\n      tz = tickStep(x0, x1, tz);\n      tz = range(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive\n    }\n\n    // Remove any thresholds outside the domain.\n    var m = tz.length;\n    while (tz[0] <= x0) tz.shift(), --m;\n    while (tz[m - 1] > x1) tz.pop(), --m;\n\n    var bins = new Array(m + 1),\n        bin;\n\n    // Initialize bins.\n    for (i = 0; i <= m; ++i) {\n      bin = bins[i] = [];\n      bin.x0 = i > 0 ? tz[i - 1] : x0;\n      bin.x1 = i < m ? tz[i] : x1;\n    }\n\n    // Assign data to bins by value, ignoring any outside the domain.\n    for (i = 0; i < n; ++i) {\n      x = values[i];\n      if (x0 <= x && x <= x1) {\n        bins[bisect(tz, x, 0, m)].push(data[i]);\n      }\n    }\n\n    return bins;\n  }\n\n  histogram.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant(_), histogram) : value;\n  };\n\n  histogram.domain = function(_) {\n    return arguments.length ? (domain = typeof _ === \"function\" ? _ : constant([_[0], _[1]]), histogram) : domain;\n  };\n\n  histogram.thresholds = function(_) {\n    return arguments.length ? (threshold = typeof _ === \"function\" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;\n  };\n\n  return histogram;\n}\n","import {map} from \"../array\";\nimport ascending from \"../ascending\";\nimport number from \"../number\";\nimport quantile from \"../quantile\";\n\nexport default function(values, min, max) {\n  values = map.call(values, number).sort(ascending);\n  return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));\n}\n","export default function(arrays) {\n  var n = arrays.length,\n      m,\n      i = -1,\n      j = 0,\n      merged,\n      array;\n\n  while (++i < n) j += arrays[i].length;\n  merged = new Array(j);\n\n  while (--n >= 0) {\n    array = arrays[n];\n    m = array.length;\n    while (--m >= 0) {\n      merged[--j] = array[m];\n    }\n  }\n\n  return merged;\n}\n","export {default as bisect, bisectRight, bisectLeft} from \"./bisect\";\nexport {default as ascending} from \"./ascending\";\nexport {default as bisector} from \"./bisector\";\nexport {default as cross} from \"./cross\";\nexport {default as descending} from \"./descending\";\nexport {default as deviation} from \"./deviation\";\nexport {default as extent} from \"./extent\";\nexport {default as histogram} from \"./histogram\";\nexport {default as thresholdFreedmanDiaconis} from \"./threshold/freedmanDiaconis\";\nexport {default as thresholdScott} from \"./threshold/scott\";\nexport {default as thresholdSturges} from \"./threshold/sturges\";\nexport {default as max} from \"./max\";\nexport {default as mean} from \"./mean\";\nexport {default as median} from \"./median\";\nexport {default as merge} from \"./merge\";\nexport {default as min} from \"./min\";\nexport {default as pairs} from \"./pairs\";\nexport {default as permute} from \"./permute\";\nexport {default as quantile} from \"./quantile\";\nexport {default as range} from \"./range\";\nexport {default as scan} from \"./scan\";\nexport {default as shuffle} from \"./shuffle\";\nexport {default as sum} from \"./sum\";\nexport {default as ticks, tickIncrement, tickStep} from \"./ticks\";\nexport {default as transpose} from \"./transpose\";\nexport {default as variance} from \"./variance\";\nexport {default as zip} from \"./zip\";\n","import {abs, epsilon} from \"../math\";\nimport clipBuffer from \"./buffer\";\nimport clipLine from \"./line\";\nimport clipPolygon from \"./polygon\";\nimport {merge} from \"d3-array\";\n\nvar clipMax = 1e9, clipMin = -clipMax;\n\n// TODO Use d3-polygons polygonContains here for the ring check?\n// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?\n\nexport function clipExtent(x0, y0, x1, y1) {\n\n  function visible(x, y) {\n    return x0 <= x && x <= x1 && y0 <= y && y <= y1;\n  }\n\n  function interpolate(from, to, direction, stream) {\n    var a = 0, a1 = 0;\n    if (from == null\n        || (a = corner(from, direction)) !== (a1 = corner(to, direction))\n        || comparePoint(from, to) < 0 ^ direction > 0) {\n      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\n      while ((a = (a + direction + 4) % 4) !== a1);\n    } else {\n      stream.point(to[0], to[1]);\n    }\n  }\n\n  function corner(p, direction) {\n    return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3\n        : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1\n        : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0\n        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon\n  }\n\n  function compareIntersection(a, b) {\n    return comparePoint(a.x, b.x);\n  }\n\n  function comparePoint(a, b) {\n    var ca = corner(a, 1),\n        cb = corner(b, 1);\n    return ca !== cb ? ca - cb\n        : ca === 0 ? b[1] - a[1]\n        : ca === 1 ? a[0] - b[0]\n        : ca === 2 ? a[1] - b[1]\n        : b[0] - a[0];\n  }\n\n  return function(stream) {\n    var activeStream = stream,\n        bufferStream = clipBuffer(),\n        segments,\n        polygon,\n        ring,\n        x__, y__, v__, // first point\n        x_, y_, v_, // previous point\n        first,\n        clean;\n\n    var clipStream = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: polygonStart,\n      polygonEnd: polygonEnd\n    };\n\n    function point(x, y) {\n      if (visible(x, y)) activeStream.point(x, y);\n    }\n\n    function polygonInside() {\n      var winding = 0;\n\n      for (var i = 0, n = polygon.length; i < n; ++i) {\n        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {\n          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];\n          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }\n          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }\n        }\n      }\n\n      return winding;\n    }\n\n    // Buffer geometry within a polygon and then clip it en masse.\n    function polygonStart() {\n      activeStream = bufferStream, segments = [], polygon = [], clean = true;\n    }\n\n    function polygonEnd() {\n      var startInside = polygonInside(),\n          cleanInside = clean && startInside,\n          visible = (segments = merge(segments)).length;\n      if (cleanInside || visible) {\n        stream.polygonStart();\n        if (cleanInside) {\n          stream.lineStart();\n          interpolate(null, null, 1, stream);\n          stream.lineEnd();\n        }\n        if (visible) {\n          clipPolygon(segments, compareIntersection, startInside, interpolate, stream);\n        }\n        stream.polygonEnd();\n      }\n      activeStream = stream, segments = polygon = ring = null;\n    }\n\n    function lineStart() {\n      clipStream.point = linePoint;\n      if (polygon) polygon.push(ring = []);\n      first = true;\n      v_ = false;\n      x_ = y_ = NaN;\n    }\n\n    // TODO rather than special-case polygons, simply handle them separately.\n    // Ideally, coincident intersection points should be jittered to avoid\n    // clipping issues.\n    function lineEnd() {\n      if (segments) {\n        linePoint(x__, y__);\n        if (v__ && v_) bufferStream.rejoin();\n        segments.push(bufferStream.result());\n      }\n      clipStream.point = point;\n      if (v_) activeStream.lineEnd();\n    }\n\n    function linePoint(x, y) {\n      var v = visible(x, y);\n      if (polygon) ring.push([x, y]);\n      if (first) {\n        x__ = x, y__ = y, v__ = v;\n        first = false;\n        if (v) {\n          activeStream.lineStart();\n          activeStream.point(x, y);\n        }\n      } else {\n        if (v && v_) activeStream.point(x, y);\n        else {\n          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],\n              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];\n          if (clipLine(a, b, x0, y0, x1, y1)) {\n            if (!v_) {\n              activeStream.lineStart();\n              activeStream.point(a[0], a[1]);\n            }\n            activeStream.point(b[0], b[1]);\n            if (!v) activeStream.lineEnd();\n            clean = false;\n          } else if (v) {\n            activeStream.lineStart();\n            activeStream.point(x, y);\n            clean = false;\n          }\n        }\n      }\n      x_ = x, y_ = y, v_ = v;\n    }\n\n    return clipStream;\n  };\n}\n\nexport default function() {\n  var x0 = 0,\n      y0 = 0,\n      x1 = 960,\n      y1 = 500,\n      cache,\n      cacheStream,\n      clip;\n\n  return clip = {\n    stream: function(stream) {\n      return cache && cacheStream === stream ? cache : cache = clipExtent(x0, y0, x1, y1)(cacheStream = stream);\n    },\n    extent: function(_) {\n      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];\n    }\n  };\n}\n","import adder from \"./adder\";\nimport {cartesian, cartesianCross, cartesianNormalizeInPlace} from \"./cartesian\";\nimport {asin, atan2, cos, epsilon, pi, quarterPi, sin, tau} from \"./math\";\n\nvar sum = adder();\n\nexport default function(polygon, point) {\n  var lambda = point[0],\n      phi = point[1],\n      normal = [sin(lambda), -cos(lambda), 0],\n      angle = 0,\n      winding = 0;\n\n  sum.reset();\n\n  for (var i = 0, n = polygon.length; i < n; ++i) {\n    if (!(m = (ring = polygon[i]).length)) continue;\n    var ring,\n        m,\n        point0 = ring[m - 1],\n        lambda0 = point0[0],\n        phi0 = point0[1] / 2 + quarterPi,\n        sinPhi0 = sin(phi0),\n        cosPhi0 = cos(phi0);\n\n    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {\n      var point1 = ring[j],\n          lambda1 = point1[0],\n          phi1 = point1[1] / 2 + quarterPi,\n          sinPhi1 = sin(phi1),\n          cosPhi1 = cos(phi1),\n          delta = lambda1 - lambda0,\n          sign = delta >= 0 ? 1 : -1,\n          absDelta = sign * delta,\n          antimeridian = absDelta > pi,\n          k = sinPhi0 * sinPhi1;\n\n      sum.add(atan2(k * sign * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));\n      angle += antimeridian ? delta + sign * tau : delta;\n\n      // Are the longitudes either side of the points meridian (lambda),\n      // and are the latitudes smaller than the parallel (phi)?\n      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {\n        var arc = cartesianCross(cartesian(point0), cartesian(point1));\n        cartesianNormalizeInPlace(arc);\n        var intersection = cartesianCross(normal, arc);\n        cartesianNormalizeInPlace(intersection);\n        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);\n        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {\n          winding += antimeridian ^ delta >= 0 ? 1 : -1;\n        }\n      }\n    }\n  }\n\n  // First, determine whether the South pole is inside or outside:\n  //\n  // It is inside if:\n  // * the polygon winds around it in a clockwise direction.\n  // * the polygon does not (cumulatively) wind around it, but has a negative\n  //   (counter-clockwise) area.\n  //\n  // Second, count the (signed) number of times a segment crosses a lambda\n  // from the point to the South pole.  If it is zero, then the point is the\n  // same side as the South pole.\n\n  return (angle < -epsilon || angle < epsilon && sum < -epsilon) ^ (winding & 1);\n}\n","import adder from \"./adder\";\nimport {abs, atan2, cos, radians, sin, sqrt} from \"./math\";\nimport noop from \"./noop\";\nimport stream from \"./stream\";\n\nvar lengthSum = adder(),\n    lambda0,\n    sinPhi0,\n    cosPhi0;\n\nvar lengthStream = {\n  sphere: noop,\n  point: noop,\n  lineStart: lengthLineStart,\n  lineEnd: noop,\n  polygonStart: noop,\n  polygonEnd: noop\n};\n\nfunction lengthLineStart() {\n  lengthStream.point = lengthPointFirst;\n  lengthStream.lineEnd = lengthLineEnd;\n}\n\nfunction lengthLineEnd() {\n  lengthStream.point = lengthStream.lineEnd = noop;\n}\n\nfunction lengthPointFirst(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  lambda0 = lambda, sinPhi0 = sin(phi), cosPhi0 = cos(phi);\n  lengthStream.point = lengthPoint;\n}\n\nfunction lengthPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var sinPhi = sin(phi),\n      cosPhi = cos(phi),\n      delta = abs(lambda - lambda0),\n      cosDelta = cos(delta),\n      sinDelta = sin(delta),\n      x = cosPhi * sinDelta,\n      y = cosPhi0 * sinPhi - sinPhi0 * cosPhi * cosDelta,\n      z = sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosDelta;\n  lengthSum.add(atan2(sqrt(x * x + y * y), z));\n  lambda0 = lambda, sinPhi0 = sinPhi, cosPhi0 = cosPhi;\n}\n\nexport default function(object) {\n  lengthSum.reset();\n  stream(object, lengthStream);\n  return +lengthSum;\n}\n","import length from \"./length\";\n\nvar coordinates = [null, null],\n    object = {type: \"LineString\", coordinates: coordinates};\n\nexport default function(a, b) {\n  coordinates[0] = a;\n  coordinates[1] = b;\n  return length(object);\n}\n","import {default as polygonContains} from \"./polygonContains\";\nimport {default as distance} from \"./distance\";\nimport {epsilon, radians} from \"./math\";\n\nvar containsObjectType = {\n  Feature: function(object, point) {\n    return containsGeometry(object.geometry, point);\n  },\n  FeatureCollection: function(object, point) {\n    var features = object.features, i = -1, n = features.length;\n    while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;\n    return false;\n  }\n};\n\nvar containsGeometryType = {\n  Sphere: function() {\n    return true;\n  },\n  Point: function(object, point) {\n    return containsPoint(object.coordinates, point);\n  },\n  MultiPoint: function(object, point) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) if (containsPoint(coordinates[i], point)) return true;\n    return false;\n  },\n  LineString: function(object, point) {\n    return containsLine(object.coordinates, point);\n  },\n  MultiLineString: function(object, point) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) if (containsLine(coordinates[i], point)) return true;\n    return false;\n  },\n  Polygon: function(object, point) {\n    return containsPolygon(object.coordinates, point);\n  },\n  MultiPolygon: function(object, point) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) if (containsPolygon(coordinates[i], point)) return true;\n    return false;\n  },\n  GeometryCollection: function(object, point) {\n    var geometries = object.geometries, i = -1, n = geometries.length;\n    while (++i < n) if (containsGeometry(geometries[i], point)) return true;\n    return false;\n  }\n};\n\nfunction containsGeometry(geometry, point) {\n  return geometry && containsGeometryType.hasOwnProperty(geometry.type)\n      ? containsGeometryType[geometry.type](geometry, point)\n      : false;\n}\n\nfunction containsPoint(coordinates, point) {\n  return distance(coordinates, point) === 0;\n}\n\nfunction containsLine(coordinates, point) {\n  var ab = distance(coordinates[0], coordinates[1]),\n      ao = distance(coordinates[0], point),\n      ob = distance(point, coordinates[1]);\n  return ao + ob <= ab + epsilon;\n}\n\nfunction containsPolygon(coordinates, point) {\n  return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));\n}\n\nfunction ringRadians(ring) {\n  return ring = ring.map(pointRadians), ring.pop(), ring;\n}\n\nfunction pointRadians(point) {\n  return [point[0] * radians, point[1] * radians];\n}\n\nexport default function(object, point) {\n  return (object && containsObjectType.hasOwnProperty(object.type)\n      ? containsObjectType[object.type]\n      : containsGeometry)(object, point);\n}\n","import {range} from \"d3-array\";\nimport {abs, ceil, epsilon} from \"./math\";\n\nfunction graticuleX(y0, y1, dy) {\n  var y = range(y0, y1 - epsilon, dy).concat(y1);\n  return function(x) { return y.map(function(y) { return [x, y]; }); };\n}\n\nfunction graticuleY(x0, x1, dx) {\n  var x = range(x0, x1 - epsilon, dx).concat(x1);\n  return function(y) { return x.map(function(x) { return [x, y]; }); };\n}\n\nexport default function graticule() {\n  var x1, x0, X1, X0,\n      y1, y0, Y1, Y0,\n      dx = 10, dy = dx, DX = 90, DY = 360,\n      x, y, X, Y,\n      precision = 2.5;\n\n  function graticule() {\n    return {type: \"MultiLineString\", coordinates: lines()};\n  }\n\n  function lines() {\n    return range(ceil(X0 / DX) * DX, X1, DX).map(X)\n        .concat(range(ceil(Y0 / DY) * DY, Y1, DY).map(Y))\n        .concat(range(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs(x % DX) > epsilon; }).map(x))\n        .concat(range(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs(y % DY) > epsilon; }).map(y));\n  }\n\n  graticule.lines = function() {\n    return lines().map(function(coordinates) { return {type: \"LineString\", coordinates: coordinates}; });\n  };\n\n  graticule.outline = function() {\n    return {\n      type: \"Polygon\",\n      coordinates: [\n        X(X0).concat(\n        Y(Y1).slice(1),\n        X(X1).reverse().slice(1),\n        Y(Y0).reverse().slice(1))\n      ]\n    };\n  };\n\n  graticule.extent = function(_) {\n    if (!arguments.length) return graticule.extentMinor();\n    return graticule.extentMajor(_).extentMinor(_);\n  };\n\n  graticule.extentMajor = function(_) {\n    if (!arguments.length) return [[X0, Y0], [X1, Y1]];\n    X0 = +_[0][0], X1 = +_[1][0];\n    Y0 = +_[0][1], Y1 = +_[1][1];\n    if (X0 > X1) _ = X0, X0 = X1, X1 = _;\n    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;\n    return graticule.precision(precision);\n  };\n\n  graticule.extentMinor = function(_) {\n    if (!arguments.length) return [[x0, y0], [x1, y1]];\n    x0 = +_[0][0], x1 = +_[1][0];\n    y0 = +_[0][1], y1 = +_[1][1];\n    if (x0 > x1) _ = x0, x0 = x1, x1 = _;\n    if (y0 > y1) _ = y0, y0 = y1, y1 = _;\n    return graticule.precision(precision);\n  };\n\n  graticule.step = function(_) {\n    if (!arguments.length) return graticule.stepMinor();\n    return graticule.stepMajor(_).stepMinor(_);\n  };\n\n  graticule.stepMajor = function(_) {\n    if (!arguments.length) return [DX, DY];\n    DX = +_[0], DY = +_[1];\n    return graticule;\n  };\n\n  graticule.stepMinor = function(_) {\n    if (!arguments.length) return [dx, dy];\n    dx = +_[0], dy = +_[1];\n    return graticule;\n  };\n\n  graticule.precision = function(_) {\n    if (!arguments.length) return precision;\n    precision = +_;\n    x = graticuleX(y0, y1, 90);\n    y = graticuleY(x0, x1, precision);\n    X = graticuleX(Y0, Y1, 90);\n    Y = graticuleY(X0, X1, precision);\n    return graticule;\n  };\n\n  return graticule\n      .extentMajor([[-180, -90 + epsilon], [180, 90 - epsilon]])\n      .extentMinor([[-180, -80 - epsilon], [180, 80 + epsilon]]);\n}\n\nexport function graticule10() {\n  return graticule()();\n}\n","import {asin, atan2, cos, degrees, haversin, radians, sin, sqrt} from \"./math\";\n\nexport default function(a, b) {\n  var x0 = a[0] * radians,\n      y0 = a[1] * radians,\n      x1 = b[0] * radians,\n      y1 = b[1] * radians,\n      cy0 = cos(y0),\n      sy0 = sin(y0),\n      cy1 = cos(y1),\n      sy1 = sin(y1),\n      kx0 = cy0 * cos(x0),\n      ky0 = cy0 * sin(x0),\n      kx1 = cy1 * cos(x1),\n      ky1 = cy1 * sin(x1),\n      d = 2 * asin(sqrt(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),\n      k = sin(d);\n\n  var interpolate = d ? function(t) {\n    var B = sin(t *= d) / k,\n        A = sin(d - t) / k,\n        x = A * kx0 + B * kx1,\n        y = A * ky0 + B * ky1,\n        z = A * sy0 + B * sy1;\n    return [\n      atan2(y, x) * degrees,\n      atan2(z, sqrt(x * x + y * y)) * degrees\n    ];\n  } : function() {\n    return [x0 * degrees, y0 * degrees];\n  };\n\n  interpolate.distance = d;\n\n  return interpolate;\n}\n","import adder from \"../adder\";\nimport {abs} from \"../math\";\nimport noop from \"../noop\";\n\nvar areaSum = adder(),\n    areaRingSum = adder(),\n    x00,\n    y00,\n    x0,\n    y0;\n\nvar areaStream = {\n  point: noop,\n  lineStart: noop,\n  lineEnd: noop,\n  polygonStart: function() {\n    areaStream.lineStart = areaRingStart;\n    areaStream.lineEnd = areaRingEnd;\n  },\n  polygonEnd: function() {\n    areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop;\n    areaSum.add(abs(areaRingSum));\n    areaRingSum.reset();\n  },\n  result: function() {\n    var area = areaSum / 2;\n    areaSum.reset();\n    return area;\n  }\n};\n\nfunction areaRingStart() {\n  areaStream.point = areaPointFirst;\n}\n\nfunction areaPointFirst(x, y) {\n  areaStream.point = areaPoint;\n  x00 = x0 = x, y00 = y0 = y;\n}\n\nfunction areaPoint(x, y) {\n  areaRingSum.add(y0 * x - x0 * y);\n  x0 = x, y0 = y;\n}\n\nfunction areaRingEnd() {\n  areaPoint(x00, y00);\n}\n\nexport default areaStream;\n","import noop from \"../noop\";\n\nvar x0 = Infinity,\n    y0 = x0,\n    x1 = -x0,\n    y1 = x1;\n\nvar boundsStream = {\n  point: boundsPoint,\n  lineStart: noop,\n  lineEnd: noop,\n  polygonStart: noop,\n  polygonEnd: noop,\n  result: function() {\n    var bounds = [[x0, y0], [x1, y1]];\n    x1 = y1 = -(y0 = x0 = Infinity);\n    return bounds;\n  }\n};\n\nfunction boundsPoint(x, y) {\n  if (x < x0) x0 = x;\n  if (x > x1) x1 = x;\n  if (y < y0) y0 = y;\n  if (y > y1) y1 = y;\n}\n\nexport default boundsStream;\n","import {sqrt} from \"../math\";\n\n// TODO Enforce positive area for exterior, negative area for interior?\n\nvar X0 = 0,\n    Y0 = 0,\n    Z0 = 0,\n    X1 = 0,\n    Y1 = 0,\n    Z1 = 0,\n    X2 = 0,\n    Y2 = 0,\n    Z2 = 0,\n    x00,\n    y00,\n    x0,\n    y0;\n\nvar centroidStream = {\n  point: centroidPoint,\n  lineStart: centroidLineStart,\n  lineEnd: centroidLineEnd,\n  polygonStart: function() {\n    centroidStream.lineStart = centroidRingStart;\n    centroidStream.lineEnd = centroidRingEnd;\n  },\n  polygonEnd: function() {\n    centroidStream.point = centroidPoint;\n    centroidStream.lineStart = centroidLineStart;\n    centroidStream.lineEnd = centroidLineEnd;\n  },\n  result: function() {\n    var centroid = Z2 ? [X2 / Z2, Y2 / Z2]\n        : Z1 ? [X1 / Z1, Y1 / Z1]\n        : Z0 ? [X0 / Z0, Y0 / Z0]\n        : [NaN, NaN];\n    X0 = Y0 = Z0 =\n    X1 = Y1 = Z1 =\n    X2 = Y2 = Z2 = 0;\n    return centroid;\n  }\n};\n\nfunction centroidPoint(x, y) {\n  X0 += x;\n  Y0 += y;\n  ++Z0;\n}\n\nfunction centroidLineStart() {\n  centroidStream.point = centroidPointFirstLine;\n}\n\nfunction centroidPointFirstLine(x, y) {\n  centroidStream.point = centroidPointLine;\n  centroidPoint(x0 = x, y0 = y);\n}\n\nfunction centroidPointLine(x, y) {\n  var dx = x - x0, dy = y - y0, z = sqrt(dx * dx + dy * dy);\n  X1 += z * (x0 + x) / 2;\n  Y1 += z * (y0 + y) / 2;\n  Z1 += z;\n  centroidPoint(x0 = x, y0 = y);\n}\n\nfunction centroidLineEnd() {\n  centroidStream.point = centroidPoint;\n}\n\nfunction centroidRingStart() {\n  centroidStream.point = centroidPointFirstRing;\n}\n\nfunction centroidRingEnd() {\n  centroidPointRing(x00, y00);\n}\n\nfunction centroidPointFirstRing(x, y) {\n  centroidStream.point = centroidPointRing;\n  centroidPoint(x00 = x0 = x, y00 = y0 = y);\n}\n\nfunction centroidPointRing(x, y) {\n  var dx = x - x0,\n      dy = y - y0,\n      z = sqrt(dx * dx + dy * dy);\n\n  X1 += z * (x0 + x) / 2;\n  Y1 += z * (y0 + y) / 2;\n  Z1 += z;\n\n  z = y0 * x - x0 * y;\n  X2 += z * (x0 + x);\n  Y2 += z * (y0 + y);\n  Z2 += z * 3;\n  centroidPoint(x0 = x, y0 = y);\n}\n\nexport default centroidStream;\n","import {tau} from \"../math\";\nimport noop from \"../noop\";\n\nexport default function PathContext(context) {\n  this._context = context;\n}\n\nPathContext.prototype = {\n  _radius: 4.5,\n  pointRadius: function(_) {\n    return this._radius = _, this;\n  },\n  polygonStart: function() {\n    this._line = 0;\n  },\n  polygonEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line === 0) this._context.closePath();\n    this._point = NaN;\n  },\n  point: function(x, y) {\n    switch (this._point) {\n      case 0: {\n        this._context.moveTo(x, y);\n        this._point = 1;\n        break;\n      }\n      case 1: {\n        this._context.lineTo(x, y);\n        break;\n      }\n      default: {\n        this._context.moveTo(x + this._radius, y);\n        this._context.arc(x, y, this._radius, 0, tau);\n        break;\n      }\n    }\n  },\n  result: noop\n};\n","import adder from \"../adder\";\nimport {sqrt} from \"../math\";\nimport noop from \"../noop\";\n\nvar lengthSum = adder(),\n    lengthRing,\n    x00,\n    y00,\n    x0,\n    y0;\n\nvar lengthStream = {\n  point: noop,\n  lineStart: function() {\n    lengthStream.point = lengthPointFirst;\n  },\n  lineEnd: function() {\n    if (lengthRing) lengthPoint(x00, y00);\n    lengthStream.point = noop;\n  },\n  polygonStart: function() {\n    lengthRing = true;\n  },\n  polygonEnd: function() {\n    lengthRing = null;\n  },\n  result: function() {\n    var length = +lengthSum;\n    lengthSum.reset();\n    return length;\n  }\n};\n\nfunction lengthPointFirst(x, y) {\n  lengthStream.point = lengthPoint;\n  x00 = x0 = x, y00 = y0 = y;\n}\n\nfunction lengthPoint(x, y) {\n  x0 -= x, y0 -= y;\n  lengthSum.add(sqrt(x0 * x0 + y0 * y0));\n  x0 = x, y0 = y;\n}\n\nexport default lengthStream;\n","export default function PathString() {\n  this._string = [];\n}\n\nPathString.prototype = {\n  _radius: 4.5,\n  _circle: circle(4.5),\n  pointRadius: function(_) {\n    if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;\n    return this;\n  },\n  polygonStart: function() {\n    this._line = 0;\n  },\n  polygonEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line === 0) this._string.push(\"Z\");\n    this._point = NaN;\n  },\n  point: function(x, y) {\n    switch (this._point) {\n      case 0: {\n        this._string.push(\"M\", x, \",\", y);\n        this._point = 1;\n        break;\n      }\n      case 1: {\n        this._string.push(\"L\", x, \",\", y);\n        break;\n      }\n      default: {\n        if (this._circle == null) this._circle = circle(this._radius);\n        this._string.push(\"M\", x, \",\", y, this._circle);\n        break;\n      }\n    }\n  },\n  result: function() {\n    if (this._string.length) {\n      var result = this._string.join(\"\");\n      this._string = [];\n      return result;\n    } else {\n      return null;\n    }\n  }\n};\n\nfunction circle(radius) {\n  return \"m0,\" + radius\n      + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + -2 * radius\n      + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + 2 * radius\n      + \"z\";\n}\n","import identity from \"../identity\";\nimport stream from \"../stream\";\nimport pathArea from \"./area\";\nimport pathBounds from \"./bounds\";\nimport pathCentroid from \"./centroid\";\nimport PathContext from \"./context\";\nimport pathMeasure from \"./measure\";\nimport PathString from \"./string\";\n\nexport default function(projection, context) {\n  var pointRadius = 4.5,\n      projectionStream,\n      contextStream;\n\n  function path(object) {\n    if (object) {\n      if (typeof pointRadius === \"function\") contextStream.pointRadius(+pointRadius.apply(this, arguments));\n      stream(object, projectionStream(contextStream));\n    }\n    return contextStream.result();\n  }\n\n  path.area = function(object) {\n    stream(object, projectionStream(pathArea));\n    return pathArea.result();\n  };\n\n  path.measure = function(object) {\n    stream(object, projectionStream(pathMeasure));\n    return pathMeasure.result();\n  };\n\n  path.bounds = function(object) {\n    stream(object, projectionStream(pathBounds));\n    return pathBounds.result();\n  };\n\n  path.centroid = function(object) {\n    stream(object, projectionStream(pathCentroid));\n    return pathCentroid.result();\n  };\n\n  path.projection = function(_) {\n    return arguments.length ? (projectionStream = _ == null ? (projection = null, identity) : (projection = _).stream, path) : projection;\n  };\n\n  path.context = function(_) {\n    if (!arguments.length) return context;\n    contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);\n    if (typeof pointRadius !== \"function\") contextStream.pointRadius(pointRadius);\n    return path;\n  };\n\n  path.pointRadius = function(_) {\n    if (!arguments.length) return pointRadius;\n    pointRadius = typeof _ === \"function\" ? _ : (contextStream.pointRadius(+_), +_);\n    return path;\n  };\n\n  return path.projection(projection).context(context);\n}\n","import clipBuffer from \"./buffer\";\nimport clipPolygon from \"./polygon\";\nimport {epsilon, halfPi} from \"../math\";\nimport polygonContains from \"../polygonContains\";\nimport {merge} from \"d3-array\";\n\nexport default function(pointVisible, clipLine, interpolate, start) {\n  return function(rotate, sink) {\n    var line = clipLine(sink),\n        rotatedStart = rotate.invert(start[0], start[1]),\n        ringBuffer = clipBuffer(),\n        ringSink = clipLine(ringBuffer),\n        polygonStarted = false,\n        polygon,\n        segments,\n        ring;\n\n    var clip = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function() {\n        clip.point = pointRing;\n        clip.lineStart = ringStart;\n        clip.lineEnd = ringEnd;\n        segments = [];\n        polygon = [];\n      },\n      polygonEnd: function() {\n        clip.point = point;\n        clip.lineStart = lineStart;\n        clip.lineEnd = lineEnd;\n        segments = merge(segments);\n        var startInside = polygonContains(polygon, rotatedStart);\n        if (segments.length) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          clipPolygon(segments, compareIntersection, startInside, interpolate, sink);\n        } else if (startInside) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          interpolate(null, null, 1, sink);\n          sink.lineEnd();\n        }\n        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;\n        segments = polygon = null;\n      },\n      sphere: function() {\n        sink.polygonStart();\n        sink.lineStart();\n        interpolate(null, null, 1, sink);\n        sink.lineEnd();\n        sink.polygonEnd();\n      }\n    };\n\n    function point(lambda, phi) {\n      var point = rotate(lambda, phi);\n      if (pointVisible(lambda = point[0], phi = point[1])) sink.point(lambda, phi);\n    }\n\n    function pointLine(lambda, phi) {\n      var point = rotate(lambda, phi);\n      line.point(point[0], point[1]);\n    }\n\n    function lineStart() {\n      clip.point = pointLine;\n      line.lineStart();\n    }\n\n    function lineEnd() {\n      clip.point = point;\n      line.lineEnd();\n    }\n\n    function pointRing(lambda, phi) {\n      ring.push([lambda, phi]);\n      var point = rotate(lambda, phi);\n      ringSink.point(point[0], point[1]);\n    }\n\n    function ringStart() {\n      ringSink.lineStart();\n      ring = [];\n    }\n\n    function ringEnd() {\n      pointRing(ring[0][0], ring[0][1]);\n      ringSink.lineEnd();\n\n      var clean = ringSink.clean(),\n          ringSegments = ringBuffer.result(),\n          i, n = ringSegments.length, m,\n          segment,\n          point;\n\n      ring.pop();\n      polygon.push(ring);\n      ring = null;\n\n      if (!n) return;\n\n      // No intersections.\n      if (clean & 1) {\n        segment = ringSegments[0];\n        if ((m = segment.length - 1) > 0) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);\n          sink.lineEnd();\n        }\n        return;\n      }\n\n      // Rejoin connected segments.\n      // TODO reuse ringBuffer.rejoin()?\n      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n\n      segments.push(ringSegments.filter(validSegment));\n    }\n\n    return clip;\n  };\n}\n\nfunction validSegment(segment) {\n  return segment.length > 1;\n}\n\n// Intersections are sorted along the clip edge. For both antimeridian cutting\n// and circle clipping, the same comparison is used.\nfunction compareIntersection(a, b) {\n  return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1])\n       - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);\n}\n","import clip from \"./index\";\nimport {abs, atan, cos, epsilon, halfPi, pi, sin} from \"../math\";\n\nexport default clip(\n  function() { return true; },\n  clipAntimeridianLine,\n  clipAntimeridianInterpolate,\n  [-pi, -halfPi]\n);\n\n// Takes a line and cuts into visible segments. Return values: 0 - there were\n// intersections or the line was empty; 1 - no intersections; 2 - there were\n// intersections, and the first and last segments should be rejoined.\nfunction clipAntimeridianLine(stream) {\n  var lambda0 = NaN,\n      phi0 = NaN,\n      sign0 = NaN,\n      clean; // no intersections\n\n  return {\n    lineStart: function() {\n      stream.lineStart();\n      clean = 1;\n    },\n    point: function(lambda1, phi1) {\n      var sign1 = lambda1 > 0 ? pi : -pi,\n          delta = abs(lambda1 - lambda0);\n      if (abs(delta - pi) < epsilon) { // line crosses a pole\n        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);\n        stream.point(sign0, phi0);\n        stream.lineEnd();\n        stream.lineStart();\n        stream.point(sign1, phi0);\n        stream.point(lambda1, phi0);\n        clean = 0;\n      } else if (sign0 !== sign1 && delta >= pi) { // line crosses antimeridian\n        if (abs(lambda0 - sign0) < epsilon) lambda0 -= sign0 * epsilon; // handle degeneracies\n        if (abs(lambda1 - sign1) < epsilon) lambda1 -= sign1 * epsilon;\n        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);\n        stream.point(sign0, phi0);\n        stream.lineEnd();\n        stream.lineStart();\n        stream.point(sign1, phi0);\n        clean = 0;\n      }\n      stream.point(lambda0 = lambda1, phi0 = phi1);\n      sign0 = sign1;\n    },\n    lineEnd: function() {\n      stream.lineEnd();\n      lambda0 = phi0 = NaN;\n    },\n    clean: function() {\n      return 2 - clean; // if intersections, rejoin first and last segments\n    }\n  };\n}\n\nfunction clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {\n  var cosPhi0,\n      cosPhi1,\n      sinLambda0Lambda1 = sin(lambda0 - lambda1);\n  return abs(sinLambda0Lambda1) > epsilon\n      ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1)\n          - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0))\n          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))\n      : (phi0 + phi1) / 2;\n}\n\nfunction clipAntimeridianInterpolate(from, to, direction, stream) {\n  var phi;\n  if (from == null) {\n    phi = direction * halfPi;\n    stream.point(-pi, phi);\n    stream.point(0, phi);\n    stream.point(pi, phi);\n    stream.point(pi, 0);\n    stream.point(pi, -phi);\n    stream.point(0, -phi);\n    stream.point(-pi, -phi);\n    stream.point(-pi, 0);\n    stream.point(-pi, phi);\n  } else if (abs(from[0] - to[0]) > epsilon) {\n    var lambda = from[0] < to[0] ? pi : -pi;\n    phi = direction * lambda / 2;\n    stream.point(-lambda, phi);\n    stream.point(0, phi);\n    stream.point(lambda, phi);\n  } else {\n    stream.point(to[0], to[1]);\n  }\n}\n","import {cartesian, cartesianAddInPlace, cartesianCross, cartesianDot, cartesianScale, spherical} from \"../cartesian\";\nimport {circleStream} from \"../circle\";\nimport {abs, cos, epsilon, pi, sqrt} from \"../math\";\nimport pointEqual from \"../pointEqual\";\nimport clip from \"./index\";\n\nexport default function(radius, delta) {\n  var cr = cos(radius),\n      smallRadius = cr > 0,\n      notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case\n\n  function interpolate(from, to, direction, stream) {\n    circleStream(stream, radius, delta, direction, from, to);\n  }\n\n  function visible(lambda, phi) {\n    return cos(lambda) * cos(phi) > cr;\n  }\n\n  // Takes a line and cuts into visible segments. Return values used for polygon\n  // clipping: 0 - there were intersections or the line was empty; 1 - no\n  // intersections 2 - there were intersections, and the first and last segments\n  // should be rejoined.\n  function clipLine(stream) {\n    var point0, // previous point\n        c0, // code for previous point\n        v0, // visibility of previous point\n        v00, // visibility of first point\n        clean; // no intersections\n    return {\n      lineStart: function() {\n        v00 = v0 = false;\n        clean = 1;\n      },\n      point: function(lambda, phi) {\n        var point1 = [lambda, phi],\n            point2,\n            v = visible(lambda, phi),\n            c = smallRadius\n              ? v ? 0 : code(lambda, phi)\n              : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;\n        if (!point0 && (v00 = v0 = v)) stream.lineStart();\n        // Handle degeneracies.\n        // TODO ignore if not clipping polygons.\n        if (v !== v0) {\n          point2 = intersect(point0, point1);\n          if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {\n            point1[0] += epsilon;\n            point1[1] += epsilon;\n            v = visible(point1[0], point1[1]);\n          }\n        }\n        if (v !== v0) {\n          clean = 0;\n          if (v) {\n            // outside going in\n            stream.lineStart();\n            point2 = intersect(point1, point0);\n            stream.point(point2[0], point2[1]);\n          } else {\n            // inside going out\n            point2 = intersect(point0, point1);\n            stream.point(point2[0], point2[1]);\n            stream.lineEnd();\n          }\n          point0 = point2;\n        } else if (notHemisphere && point0 && smallRadius ^ v) {\n          var t;\n          // If the codes for two points are different, or are both zero,\n          // and there this segment intersects with the small circle.\n          if (!(c & c0) && (t = intersect(point1, point0, true))) {\n            clean = 0;\n            if (smallRadius) {\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n            } else {\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n            }\n          }\n        }\n        if (v && (!point0 || !pointEqual(point0, point1))) {\n          stream.point(point1[0], point1[1]);\n        }\n        point0 = point1, v0 = v, c0 = c;\n      },\n      lineEnd: function() {\n        if (v0) stream.lineEnd();\n        point0 = null;\n      },\n      // Rejoin first and last segments if there were intersections and the first\n      // and last points were visible.\n      clean: function() {\n        return clean | ((v00 && v0) << 1);\n      }\n    };\n  }\n\n  // Intersects the great circle between a and b with the clip circle.\n  function intersect(a, b, two) {\n    var pa = cartesian(a),\n        pb = cartesian(b);\n\n    // We have two planes, n1.p = d1 and n2.p = d2.\n    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1  n2).\n    var n1 = [1, 0, 0], // normal\n        n2 = cartesianCross(pa, pb),\n        n2n2 = cartesianDot(n2, n2),\n        n1n2 = n2[0], // cartesianDot(n1, n2),\n        determinant = n2n2 - n1n2 * n1n2;\n\n    // Two polar points.\n    if (!determinant) return !two && a;\n\n    var c1 =  cr * n2n2 / determinant,\n        c2 = -cr * n1n2 / determinant,\n        n1xn2 = cartesianCross(n1, n2),\n        A = cartesianScale(n1, c1),\n        B = cartesianScale(n2, c2);\n    cartesianAddInPlace(A, B);\n\n    // Solve |p(t)|^2 = 1.\n    var u = n1xn2,\n        w = cartesianDot(A, u),\n        uu = cartesianDot(u, u),\n        t2 = w * w - uu * (cartesianDot(A, A) - 1);\n\n    if (t2 < 0) return;\n\n    var t = sqrt(t2),\n        q = cartesianScale(u, (-w - t) / uu);\n    cartesianAddInPlace(q, A);\n    q = spherical(q);\n\n    if (!two) return q;\n\n    // Two intersection points.\n    var lambda0 = a[0],\n        lambda1 = b[0],\n        phi0 = a[1],\n        phi1 = b[1],\n        z;\n\n    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;\n\n    var delta = lambda1 - lambda0,\n        polar = abs(delta - pi) < epsilon,\n        meridian = polar || delta < epsilon;\n\n    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;\n\n    // Check that the first point is between a and b.\n    if (meridian\n        ? polar\n          ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1)\n          : phi0 <= q[1] && q[1] <= phi1\n        : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {\n      var q1 = cartesianScale(u, (-w + t) / uu);\n      cartesianAddInPlace(q1, A);\n      return [q, spherical(q1)];\n    }\n  }\n\n  // Generates a 4-bit vector representing the location of a point relative to\n  // the small circle's bounding box.\n  function code(lambda, phi) {\n    var r = smallRadius ? radius : pi - radius,\n        code = 0;\n    if (lambda < -r) code |= 1; // left\n    else if (lambda > r) code |= 2; // right\n    if (phi < -r) code |= 4; // below\n    else if (phi > r) code |= 8; // above\n    return code;\n  }\n\n  return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);\n}\n","export default function(x) {\n  return x;\n}\n","export default function(methods) {\n  return {\n    stream: transformer(methods)\n  };\n}\n\nexport function transformer(methods) {\n  return function(stream) {\n    var s = new TransformStream;\n    for (var key in methods) s[key] = methods[key];\n    s.stream = stream;\n    return s;\n  };\n}\n\nfunction TransformStream() {}\n\nTransformStream.prototype = {\n  constructor: TransformStream,\n  point: function(x, y) { this.stream.point(x, y); },\n  sphere: function() { this.stream.sphere(); },\n  lineStart: function() { this.stream.lineStart(); },\n  lineEnd: function() { this.stream.lineEnd(); },\n  polygonStart: function() { this.stream.polygonStart(); },\n  polygonEnd: function() { this.stream.polygonEnd(); }\n};\n","import {default as geoStream} from \"../stream\";\nimport boundsStream from \"../path/bounds\";\n\nexport function fitExtent(projection, extent, object) {\n  var w = extent[1][0] - extent[0][0],\n      h = extent[1][1] - extent[0][1],\n      clip = projection.clipExtent && projection.clipExtent();\n\n  projection\n      .scale(150)\n      .translate([0, 0]);\n\n  if (clip != null) projection.clipExtent(null);\n\n  geoStream(object, projection.stream(boundsStream));\n\n  var b = boundsStream.result(),\n      k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),\n      x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,\n      y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;\n\n  if (clip != null) projection.clipExtent(clip);\n\n  return projection\n      .scale(k * 150)\n      .translate([x, y]);\n}\n\nexport function fitSize(projection, size, object) {\n  return fitExtent(projection, [[0, 0], size], object);\n}\n","import {cartesian} from \"../cartesian\";\nimport {abs, asin, atan2, cos, epsilon, radians, sqrt} from \"../math\";\nimport {transformer} from \"../transform\";\n\nvar maxDepth = 16, // maximum depth of subdivision\n    cosMinDistance = cos(30 * radians); // cos(minimum angular distance)\n\nexport default function(project, delta2) {\n  return +delta2 ? resample(project, delta2) : resampleNone(project);\n}\n\nfunction resampleNone(project) {\n  return transformer({\n    point: function(x, y) {\n      x = project(x, y);\n      this.stream.point(x[0], x[1]);\n    }\n  });\n}\n\nfunction resample(project, delta2) {\n\n  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {\n    var dx = x1 - x0,\n        dy = y1 - y0,\n        d2 = dx * dx + dy * dy;\n    if (d2 > 4 * delta2 && depth--) {\n      var a = a0 + a1,\n          b = b0 + b1,\n          c = c0 + c1,\n          m = sqrt(a * a + b * b + c * c),\n          phi2 = asin(c /= m),\n          lambda2 = abs(abs(c) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a),\n          p = project(lambda2, phi2),\n          x2 = p[0],\n          y2 = p[1],\n          dx2 = x2 - x0,\n          dy2 = y2 - y0,\n          dz = dy * dx2 - dx * dy2;\n      if (dz * dz / d2 > delta2 // perpendicular projected distance\n          || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end\n          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance\n        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);\n        stream.point(x2, y2);\n        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);\n      }\n    }\n  }\n  return function(stream) {\n    var lambda00, x00, y00, a00, b00, c00, // first point\n        lambda0, x0, y0, a0, b0, c0; // previous point\n\n    var resampleStream = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },\n      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }\n    };\n\n    function point(x, y) {\n      x = project(x, y);\n      stream.point(x[0], x[1]);\n    }\n\n    function lineStart() {\n      x0 = NaN;\n      resampleStream.point = linePoint;\n      stream.lineStart();\n    }\n\n    function linePoint(lambda, phi) {\n      var c = cartesian([lambda, phi]), p = project(lambda, phi);\n      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);\n      stream.point(x0, y0);\n    }\n\n    function lineEnd() {\n      resampleStream.point = point;\n      stream.lineEnd();\n    }\n\n    function ringStart() {\n      lineStart();\n      resampleStream.point = ringPoint;\n      resampleStream.lineEnd = ringEnd;\n    }\n\n    function ringPoint(lambda, phi) {\n      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;\n      resampleStream.point = linePoint;\n    }\n\n    function ringEnd() {\n      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);\n      resampleStream.lineEnd = lineEnd;\n      lineEnd();\n    }\n\n    return resampleStream;\n  };\n}\n","import clipAntimeridian from \"../clip/antimeridian\";\nimport clipCircle from \"../clip/circle\";\nimport {clipExtent} from \"../clip/extent\";\nimport compose from \"../compose\";\nimport identity from \"../identity\";\nimport {degrees, radians, sqrt} from \"../math\";\nimport {rotateRadians} from \"../rotation\";\nimport {transformer} from \"../transform\";\nimport {fitExtent, fitSize} from \"./fit\";\nimport resample from \"./resample\";\n\nvar transformRadians = transformer({\n  point: function(x, y) {\n    this.stream.point(x * radians, y * radians);\n  }\n});\n\nexport default function projection(project) {\n  return projectionMutator(function() { return project; })();\n}\n\nexport function projectionMutator(projectAt) {\n  var project,\n      k = 150, // scale\n      x = 480, y = 250, // translate\n      dx, dy, lambda = 0, phi = 0, // center\n      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, projectRotate, // rotate\n      theta = null, preclip = clipAntimeridian, // clip angle\n      x0 = null, y0, x1, y1, postclip = identity, // clip extent\n      delta2 = 0.5, projectResample = resample(projectTransform, delta2), // precision\n      cache,\n      cacheStream;\n\n  function projection(point) {\n    point = projectRotate(point[0] * radians, point[1] * radians);\n    return [point[0] * k + dx, dy - point[1] * k];\n  }\n\n  function invert(point) {\n    point = projectRotate.invert((point[0] - dx) / k, (dy - point[1]) / k);\n    return point && [point[0] * degrees, point[1] * degrees];\n  }\n\n  function projectTransform(x, y) {\n    return x = project(x, y), [x[0] * k + dx, dy - x[1] * k];\n  }\n\n  projection.stream = function(stream) {\n    return cache && cacheStream === stream ? cache : cache = transformRadians(preclip(rotate, projectResample(postclip(cacheStream = stream))));\n  };\n\n  projection.clipAngle = function(_) {\n    return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians, 6 * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;\n  };\n\n  projection.clipExtent = function(_) {\n    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n  };\n\n  projection.scale = function(_) {\n    return arguments.length ? (k = +_, recenter()) : k;\n  };\n\n  projection.translate = function(_) {\n    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];\n  };\n\n  projection.center = function(_) {\n    return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];\n  };\n\n  projection.rotate = function(_) {\n    return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];\n  };\n\n  projection.precision = function(_) {\n    return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);\n  };\n\n  projection.fitExtent = function(extent, object) {\n    return fitExtent(projection, extent, object);\n  };\n\n  projection.fitSize = function(size, object) {\n    return fitSize(projection, size, object);\n  };\n\n  function recenter() {\n    projectRotate = compose(rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma), project);\n    var center = project(lambda, phi);\n    dx = x - center[0] * k;\n    dy = y + center[1] * k;\n    return reset();\n  }\n\n  function reset() {\n    cache = cacheStream = null;\n    return projection;\n  }\n\n  return function() {\n    project = projectAt.apply(this, arguments);\n    projection.invert = project.invert && invert;\n    return recenter();\n  };\n}\n","import {degrees, pi, radians} from \"../math\";\nimport {projectionMutator} from \"./index\";\n\nexport function conicProjection(projectAt) {\n  var phi0 = 0,\n      phi1 = pi / 3,\n      m = projectionMutator(projectAt),\n      p = m(phi0, phi1);\n\n  p.parallels = function(_) {\n    return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];\n  };\n\n  return p;\n}\n","import {asin, cos, sin} from \"../math\";\n\nexport function cylindricalEqualAreaRaw(phi0) {\n  var cosPhi0 = cos(phi0);\n\n  function forward(lambda, phi) {\n    return [lambda * cosPhi0, sin(phi) / cosPhi0];\n  }\n\n  forward.invert = function(x, y) {\n    return [x / cosPhi0, asin(y * cosPhi0)];\n  };\n\n  return forward;\n}\n","import {abs, asin, atan2, cos, epsilon, sign, sin, sqrt} from \"../math\";\nimport {conicProjection} from \"./conic\";\nimport {cylindricalEqualAreaRaw} from \"./cylindricalEqualArea\";\n\nexport function conicEqualAreaRaw(y0, y1) {\n  var sy0 = sin(y0), n = (sy0 + sin(y1)) / 2;\n\n  // Are the parallels symmetrical around the Equator?\n  if (abs(n) < epsilon) return cylindricalEqualAreaRaw(y0);\n\n  var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c) / n;\n\n  function project(x, y) {\n    var r = sqrt(c - 2 * n * sin(y)) / n;\n    return [r * sin(x *= n), r0 - r * cos(x)];\n  }\n\n  project.invert = function(x, y) {\n    var r0y = r0 - y;\n    return [atan2(x, abs(r0y)) / n * sign(r0y), asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];\n  };\n\n  return project;\n}\n\nexport default function() {\n  return conicProjection(conicEqualAreaRaw)\n      .scale(155.424)\n      .center([0, 33.6442]);\n}\n","import conicEqualArea from \"./conicEqualArea\";\n\nexport default function() {\n  return conicEqualArea()\n      .parallels([29.5, 45.5])\n      .scale(1070)\n      .translate([480, 250])\n      .rotate([96, 0])\n      .center([-0.6, 38.7]);\n}\n","import {epsilon} from \"../math\";\nimport albers from \"./albers\";\nimport conicEqualArea from \"./conicEqualArea\";\nimport {fitExtent, fitSize} from \"./fit\";\n\n// The projections must have mutually exclusive clip regions on the sphere,\n// as this will avoid emitting interleaving lines and polygons.\nfunction multiplex(streams) {\n  var n = streams.length;\n  return {\n    point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },\n    sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },\n    lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },\n    lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },\n    polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },\n    polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }\n  };\n}\n\n// A composite projection for the United States, configured by default for\n// 960500. The projection also works quite well at 960600 if you change the\n// scale to 1285 and adjust the translate accordingly. The set of standard\n// parallels for each region comes from USGS, which is published here:\n// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers\nexport default function() {\n  var cache,\n      cacheStream,\n      lower48 = albers(), lower48Point,\n      alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338\n      hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007\n      point, pointStream = {point: function(x, y) { point = [x, y]; }};\n\n  function albersUsa(coordinates) {\n    var x = coordinates[0], y = coordinates[1];\n    return point = null,\n        (lower48Point.point(x, y), point)\n        || (alaskaPoint.point(x, y), point)\n        || (hawaiiPoint.point(x, y), point);\n  }\n\n  albersUsa.invert = function(coordinates) {\n    var k = lower48.scale(),\n        t = lower48.translate(),\n        x = (coordinates[0] - t[0]) / k,\n        y = (coordinates[1] - t[1]) / k;\n    return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska\n        : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii\n        : lower48).invert(coordinates);\n  };\n\n  albersUsa.stream = function(stream) {\n    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);\n  };\n\n  albersUsa.precision = function(_) {\n    if (!arguments.length) return lower48.precision();\n    lower48.precision(_), alaska.precision(_), hawaii.precision(_);\n    return reset();\n  };\n\n  albersUsa.scale = function(_) {\n    if (!arguments.length) return lower48.scale();\n    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);\n    return albersUsa.translate(lower48.translate());\n  };\n\n  albersUsa.translate = function(_) {\n    if (!arguments.length) return lower48.translate();\n    var k = lower48.scale(), x = +_[0], y = +_[1];\n\n    lower48Point = lower48\n        .translate(_)\n        .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])\n        .stream(pointStream);\n\n    alaskaPoint = alaska\n        .translate([x - 0.307 * k, y + 0.201 * k])\n        .clipExtent([[x - 0.425 * k + epsilon, y + 0.120 * k + epsilon], [x - 0.214 * k - epsilon, y + 0.234 * k - epsilon]])\n        .stream(pointStream);\n\n    hawaiiPoint = hawaii\n        .translate([x - 0.205 * k, y + 0.212 * k])\n        .clipExtent([[x - 0.214 * k + epsilon, y + 0.166 * k + epsilon], [x - 0.115 * k - epsilon, y + 0.234 * k - epsilon]])\n        .stream(pointStream);\n\n    return reset();\n  };\n\n  albersUsa.fitExtent = function(extent, object) {\n    return fitExtent(albersUsa, extent, object);\n  };\n\n  albersUsa.fitSize = function(size, object) {\n    return fitSize(albersUsa, size, object);\n  };\n\n  function reset() {\n    cache = cacheStream = null;\n    return albersUsa;\n  }\n\n  return albersUsa.scale(1070);\n}\n","import {asin, atan2, cos, sin, sqrt} from \"../math\";\n\nexport function azimuthalRaw(scale) {\n  return function(x, y) {\n    var cx = cos(x),\n        cy = cos(y),\n        k = scale(cx * cy);\n    return [\n      k * cy * sin(x),\n      k * sin(y)\n    ];\n  }\n}\n\nexport function azimuthalInvert(angle) {\n  return function(x, y) {\n    var z = sqrt(x * x + y * y),\n        c = angle(z),\n        sc = sin(c),\n        cc = cos(c);\n    return [\n      atan2(x * sc, z * cc),\n      asin(z && y * sc / z)\n    ];\n  }\n}\n","import {asin, sqrt} from \"../math\";\nimport {azimuthalRaw, azimuthalInvert} from \"./azimuthal\";\nimport projection from \"./index\";\n\nexport var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {\n  return sqrt(2 / (1 + cxcy));\n});\n\nazimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {\n  return 2 * asin(z / 2);\n});\n\nexport default function() {\n  return projection(azimuthalEqualAreaRaw)\n      .scale(124.75)\n      .clipAngle(180 - 1e-3);\n}\n","import {acos, sin} from \"../math\";\nimport {azimuthalRaw, azimuthalInvert} from \"./azimuthal\";\nimport projection from \"./index\";\n\nexport var azimuthalEquidistantRaw = azimuthalRaw(function(c) {\n  return (c = acos(c)) && c / sin(c);\n});\n\nazimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {\n  return z;\n});\n\nexport default function() {\n  return projection(azimuthalEquidistantRaw)\n      .scale(79.4188)\n      .clipAngle(180 - 1e-3);\n}\n","import {atan, exp, halfPi, log, pi, tan, tau} from \"../math\";\nimport rotation from \"../rotation\";\nimport projection from \"./index\";\n\nexport function mercatorRaw(lambda, phi) {\n  return [lambda, log(tan((halfPi + phi) / 2))];\n}\n\nmercatorRaw.invert = function(x, y) {\n  return [x, 2 * atan(exp(y)) - halfPi];\n};\n\nexport default function() {\n  return mercatorProjection(mercatorRaw)\n      .scale(961 / tau);\n}\n\nexport function mercatorProjection(project) {\n  var m = projection(project),\n      center = m.center,\n      scale = m.scale,\n      translate = m.translate,\n      clipExtent = m.clipExtent,\n      x0 = null, y0, x1, y1; // clip extent\n\n  m.scale = function(_) {\n    return arguments.length ? (scale(_), reclip()) : scale();\n  };\n\n  m.translate = function(_) {\n    return arguments.length ? (translate(_), reclip()) : translate();\n  };\n\n  m.center = function(_) {\n    return arguments.length ? (center(_), reclip()) : center();\n  };\n\n  m.clipExtent = function(_) {\n    return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n  };\n\n  function reclip() {\n    var k = pi * scale(),\n        t = m(rotation(m.rotate()).invert([0, 0]));\n    return clipExtent(x0 == null\n        ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw\n        ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]\n        : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);\n  }\n\n  return reclip();\n}\n","import {abs, atan, atan2, cos, epsilon, halfPi, log, pow, sign, sin, sqrt, tan} from \"../math\";\nimport {conicProjection} from \"./conic\";\nimport {mercatorRaw} from \"./mercator\";\n\nfunction tany(y) {\n  return tan((halfPi + y) / 2);\n}\n\nexport function conicConformalRaw(y0, y1) {\n  var cy0 = cos(y0),\n      n = y0 === y1 ? sin(y0) : log(cy0 / cos(y1)) / log(tany(y1) / tany(y0)),\n      f = cy0 * pow(tany(y0), n) / n;\n\n  if (!n) return mercatorRaw;\n\n  function project(x, y) {\n    if (f > 0) { if (y < -halfPi + epsilon) y = -halfPi + epsilon; }\n    else { if (y > halfPi - epsilon) y = halfPi - epsilon; }\n    var r = f / pow(tany(y), n);\n    return [r * sin(n * x), f - r * cos(n * x)];\n  }\n\n  project.invert = function(x, y) {\n    var fy = f - y, r = sign(n) * sqrt(x * x + fy * fy);\n    return [atan2(x, abs(fy)) / n * sign(fy), 2 * atan(pow(f / r, 1 / n)) - halfPi];\n  };\n\n  return project;\n}\n\nexport default function() {\n  return conicProjection(conicConformalRaw)\n      .scale(109.5)\n      .parallels([30, 30]);\n}\n","import projection from \"./index\";\n\nexport function equirectangularRaw(lambda, phi) {\n  return [lambda, phi];\n}\n\nequirectangularRaw.invert = equirectangularRaw;\n\nexport default function() {\n  return projection(equirectangularRaw)\n      .scale(152.63);\n}\n","import {abs, atan2, cos, epsilon, sign, sin, sqrt} from \"../math\";\nimport {conicProjection} from \"./conic\";\nimport {equirectangularRaw} from \"./equirectangular\";\n\nexport function conicEquidistantRaw(y0, y1) {\n  var cy0 = cos(y0),\n      n = y0 === y1 ? sin(y0) : (cy0 - cos(y1)) / (y1 - y0),\n      g = cy0 / n + y0;\n\n  if (abs(n) < epsilon) return equirectangularRaw;\n\n  function project(x, y) {\n    var gy = g - y, nx = n * x;\n    return [gy * sin(nx), g - gy * cos(nx)];\n  }\n\n  project.invert = function(x, y) {\n    var gy = g - y;\n    return [atan2(x, abs(gy)) / n * sign(gy), g - sign(n) * sqrt(x * x + gy * gy)];\n  };\n\n  return project;\n}\n\nexport default function() {\n  return conicProjection(conicEquidistantRaw)\n      .scale(131.154)\n      .center([0, 13.9389]);\n}\n","import {atan, cos, sin} from \"../math\";\nimport {azimuthalInvert} from \"./azimuthal\";\nimport projection from \"./index\";\n\nexport function gnomonicRaw(x, y) {\n  var cy = cos(y), k = cos(x) * cy;\n  return [cy * sin(x) / k, sin(y) / k];\n}\n\ngnomonicRaw.invert = azimuthalInvert(atan);\n\nexport default function() {\n  return projection(gnomonicRaw)\n      .scale(144.049)\n      .clipAngle(60);\n}\n","import {clipExtent} from \"../clip/extent\";\nimport identity from \"../identity\";\nimport {transformer} from \"../transform\";\nimport {fitExtent, fitSize} from \"./fit\";\n\nfunction scaleTranslate(kx, ky, tx, ty) {\n  return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? identity : transformer({\n    point: function(x, y) {\n      this.stream.point(x * kx + tx, y * ky + ty);\n    }\n  });\n}\n\nexport default function() {\n  var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, transform = identity, // scale, translate and reflect\n      x0 = null, y0, x1, y1, clip = identity, // clip extent\n      cache,\n      cacheStream,\n      projection;\n\n  function reset() {\n    cache = cacheStream = null;\n    return projection;\n  }\n\n  return projection = {\n    stream: function(stream) {\n      return cache && cacheStream === stream ? cache : cache = transform(clip(cacheStream = stream));\n    },\n    clipExtent: function(_) {\n      return arguments.length ? (clip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n    },\n    scale: function(_) {\n      return arguments.length ? (transform = scaleTranslate((k = +_) * sx, k * sy, tx, ty), reset()) : k;\n    },\n    translate: function(_) {\n      return arguments.length ? (transform = scaleTranslate(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];\n    },\n    reflectX: function(_) {\n      return arguments.length ? (transform = scaleTranslate(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;\n    },\n    reflectY: function(_) {\n      return arguments.length ? (transform = scaleTranslate(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;\n    },\n    fitExtent: function(extent, object) {\n      return fitExtent(projection, extent, object);\n    },\n    fitSize: function(size, object) {\n      return fitSize(projection, size, object);\n    }\n  };\n}\n","import projection from \"./index\";\nimport {abs, epsilon} from \"../math\";\n\nexport function naturalEarth1Raw(lambda, phi) {\n  var phi2 = phi * phi, phi4 = phi2 * phi2;\n  return [\n    lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),\n    phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))\n  ];\n}\n\nnaturalEarth1Raw.invert = function(x, y) {\n  var phi = y, i = 25, delta;\n  do {\n    var phi2 = phi * phi, phi4 = phi2 * phi2;\n    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /\n        (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));\n  } while (abs(delta) > epsilon && --i > 0);\n  return [\n    x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),\n    phi\n  ];\n};\n\nexport default function() {\n  return projection(naturalEarth1Raw)\n      .scale(175.295);\n}\n","import {asin, cos, epsilon, sin} from \"../math\";\nimport {azimuthalInvert} from \"./azimuthal\";\nimport projection from \"./index\";\n\nexport function orthographicRaw(x, y) {\n  return [cos(y) * sin(x), sin(y)];\n}\n\northographicRaw.invert = azimuthalInvert(asin);\n\nexport default function() {\n  return projection(orthographicRaw)\n      .scale(249.5)\n      .clipAngle(90 + epsilon);\n}\n","import {atan, cos, sin} from \"../math\";\nimport {azimuthalInvert} from \"./azimuthal\";\nimport projection from \"./index\";\n\nexport function stereographicRaw(x, y) {\n  var cy = cos(y), k = 1 + cos(x) * cy;\n  return [cy * sin(x) / k, sin(y) / k];\n}\n\nstereographicRaw.invert = azimuthalInvert(function(z) {\n  return 2 * atan(z);\n});\n\nexport default function() {\n  return projection(stereographicRaw)\n      .scale(250)\n      .clipAngle(142);\n}\n","import {atan, exp, halfPi, log, tan} from \"../math\";\nimport {mercatorProjection} from \"./mercator\";\n\nexport function transverseMercatorRaw(lambda, phi) {\n  return [log(tan((halfPi + phi) / 2)), -lambda];\n}\n\ntransverseMercatorRaw.invert = function(x, y) {\n  return [-y, 2 * atan(exp(x)) - halfPi];\n};\n\nexport default function() {\n  var m = mercatorProjection(transverseMercatorRaw),\n      center = m.center,\n      rotate = m.rotate;\n\n  m.center = function(_) {\n    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);\n  };\n\n  m.rotate = function(_) {\n    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);\n  };\n\n  return rotate([0, 0, 90])\n      .scale(159.155);\n}\n","export {default as geoArea} from \"./src/area\";\nexport {default as geoBounds} from \"./src/bounds\";\nexport {default as geoCentroid} from \"./src/centroid\";\nexport {default as geoCircle} from \"./src/circle\";\nexport {default as geoClipExtent} from \"./src/clip/extent\"; // DEPRECATED! Use d3.geoIdentity().clipExtent().\nexport {default as geoContains} from \"./src/contains\";\nexport {default as geoDistance} from \"./src/distance\";\nexport {default as geoGraticule, graticule10 as geoGraticule10} from \"./src/graticule\";\nexport {default as geoInterpolate} from \"./src/interpolate\";\nexport {default as geoLength} from \"./src/length\";\nexport {default as geoPath} from \"./src/path/index\";\nexport {default as geoAlbers} from \"./src/projection/albers\";\nexport {default as geoAlbersUsa} from \"./src/projection/albersUsa\";\nexport {default as geoAzimuthalEqualArea, azimuthalEqualAreaRaw as geoAzimuthalEqualAreaRaw} from \"./src/projection/azimuthalEqualArea\";\nexport {default as geoAzimuthalEquidistant, azimuthalEquidistantRaw as geoAzimuthalEquidistantRaw} from \"./src/projection/azimuthalEquidistant\";\nexport {default as geoConicConformal, conicConformalRaw as geoConicConformalRaw} from \"./src/projection/conicConformal\";\nexport {default as geoConicEqualArea, conicEqualAreaRaw as geoConicEqualAreaRaw} from \"./src/projection/conicEqualArea\";\nexport {default as geoConicEquidistant, conicEquidistantRaw as geoConicEquidistantRaw} from \"./src/projection/conicEquidistant\";\nexport {default as geoEquirectangular, equirectangularRaw as geoEquirectangularRaw} from \"./src/projection/equirectangular\";\nexport {default as geoGnomonic, gnomonicRaw as geoGnomonicRaw} from \"./src/projection/gnomonic\";\nexport {default as geoIdentity} from \"./src/projection/identity\";\nexport {default as geoProjection, projectionMutator as geoProjectionMutator} from \"./src/projection/index\";\nexport {default as geoMercator, mercatorRaw as geoMercatorRaw} from \"./src/projection/mercator\";\nexport {default as geoNaturalEarth1, naturalEarth1Raw as geoNaturalEarth1Raw} from \"./src/projection/naturalEarth1\";\nexport {default as geoOrthographic, orthographicRaw as geoOrthographicRaw} from \"./src/projection/orthographic\";\nexport {default as geoStereographic, stereographicRaw as geoStereographicRaw} from \"./src/projection/stereographic\";\nexport {default as geoTransverseMercator, transverseMercatorRaw as geoTransverseMercatorRaw} from \"./src/projection/transverseMercator\";\nexport {default as geoRotation} from \"./src/rotation\";\nexport {default as geoStream} from \"./src/stream\";\nexport {default as geoTransform} from \"./src/transform\";\n","// index.js\nimport { center } from \"@turf/center\";\nimport jsts from \"@turf/jsts\";\nimport { geomEach, featureEach } from \"@turf/meta\";\nimport { geoAzimuthalEquidistant } from \"d3-geo\";\nimport {\n  feature,\n  featureCollection,\n  radiansToLength,\n  lengthToRadians,\n  earthRadius\n} from \"@turf/helpers\";\nvar { BufferOp, GeoJSONReader, GeoJSONWriter } = jsts;\nfunction buffer(geojson, radius, options) {\n  options = options || {};\n  var units = options.units || \"kilometers\";\n  var steps = options.steps || 8;\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (typeof options !== \"object\") throw new Error(\"options must be an object\");\n  if (typeof steps !== \"number\") throw new Error(\"steps must be an number\");\n  if (radius === void 0) throw new Error(\"radius is required\");\n  if (steps <= 0) throw new Error(\"steps must be greater than 0\");\n  var results = [];\n  switch (geojson.type) {\n    case \"GeometryCollection\":\n      geomEach(geojson, function(geometry) {\n        var buffered = bufferFeature(geometry, radius, units, steps);\n        if (buffered) results.push(buffered);\n      });\n      return featureCollection(results);\n    case \"FeatureCollection\":\n      featureEach(geojson, function(feature2) {\n        var multiBuffered = bufferFeature(feature2, radius, units, steps);\n        if (multiBuffered) {\n          featureEach(multiBuffered, function(buffered) {\n            if (buffered) results.push(buffered);\n          });\n        }\n      });\n      return featureCollection(results);\n  }\n  return bufferFeature(geojson, radius, units, steps);\n}\nfunction bufferFeature(geojson, radius, units, steps) {\n  var properties = geojson.properties || {};\n  var geometry = geojson.type === \"Feature\" ? geojson.geometry : geojson;\n  if (geometry.type === \"GeometryCollection\") {\n    var results = [];\n    geomEach(geojson, function(geometry2) {\n      var buffered2 = bufferFeature(geometry2, radius, units, steps);\n      if (buffered2) results.push(buffered2);\n    });\n    return featureCollection(results);\n  }\n  var projection = defineProjection(geometry);\n  var projected = {\n    type: geometry.type,\n    coordinates: projectCoords(geometry.coordinates, projection)\n  };\n  var reader = new GeoJSONReader();\n  var geom = reader.read(projected);\n  var distance = radiansToLength(lengthToRadians(radius, units), \"meters\");\n  var buffered = BufferOp.bufferOp(geom, distance, steps);\n  var writer = new GeoJSONWriter();\n  buffered = writer.write(buffered);\n  if (coordsIsNaN(buffered.coordinates)) return void 0;\n  var result = {\n    type: buffered.type,\n    coordinates: unprojectCoords(buffered.coordinates, projection)\n  };\n  return feature(result, properties);\n}\nfunction coordsIsNaN(coords) {\n  if (Array.isArray(coords[0])) return coordsIsNaN(coords[0]);\n  return isNaN(coords[0]);\n}\nfunction projectCoords(coords, proj) {\n  if (typeof coords[0] !== \"object\") return proj(coords);\n  return coords.map(function(coord) {\n    return projectCoords(coord, proj);\n  });\n}\nfunction unprojectCoords(coords, proj) {\n  if (typeof coords[0] !== \"object\") return proj.invert(coords);\n  return coords.map(function(coord) {\n    return unprojectCoords(coord, proj);\n  });\n}\nfunction defineProjection(geojson) {\n  var coords = center(geojson).geometry.coordinates;\n  var rotation = [-coords[0], -coords[1]];\n  return geoAzimuthalEquidistant().rotate(rotation).scale(earthRadius);\n}\nvar turf_buffer_default = buffer;\nexport {\n  buffer,\n  turf_buffer_default as default\n};\n//# sourceMappingURL=index.js.map","function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n\n  _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nvar Control = /*#__PURE__*/function () {\n  function Control() {\n    this._initialUpdateBind = this._initialUpdate.bind(this);\n  }\n\n  var _proto = Control.prototype;\n\n  _proto._initialUpdate = function _initialUpdate() {\n    var _this$_map;\n\n    // We only update the style once\n    (_this$_map = this._map) == null ? void 0 : _this$_map.off('styledata', this._initialUpdateBind);\n  };\n\n  _proto.onAdd = function onAdd(map) {\n    this._map = map;\n\n    this._map.on('styledata', this._initialUpdateBind);\n\n    this._container = document.createElement('div');\n    return this._container;\n  };\n\n  _proto.onRemove = function onRemove() {\n    var _this$_map2;\n\n    (_this$_map2 = this._map) == null ? void 0 : _this$_map2.off('styledata', this._initialUpdateBind);\n    this._map = undefined;\n  };\n\n  return Control;\n}();\n\n/**\r\n * Create a new [Mapbox GL JS plugin](https://www.mapbox.com/blog/build-mapbox-gl-js-plugins/) that\r\n * modifies the layers of the map style to use the 'text-field' that matches the browser language.\r\n */\n\nvar OpenMapTilesLanguage = /*#__PURE__*/function (_Control) {\n  _inheritsLoose(OpenMapTilesLanguage, _Control);\n\n  function OpenMapTilesLanguage(options) {\n    var _this;\n\n    _this = _Control.call(this) || this;\n    _this.isTokenField = /^\\{name/;\n    _this._options = options;\n    _this._isLanguageField = (options == null ? void 0 : options.languageField) || /^name:/;\n\n    _this._getLanguageField = (options == null ? void 0 : options.getLanguageField) || function nameField(language) {\n      return language === 'mul' ? 'name' : \"name:\" + language;\n    };\n\n    _this._excludedLayerIds = (options == null ? void 0 : options.excludedLayerIds) || [];\n    _this.supportedLanguages = (options == null ? void 0 : options.supportedLanguages) || ['am', 'ar', 'az', 'be', 'bg', 'br', 'bs', 'ca', 'co', 'cs', 'cy', 'da', 'de', 'el', 'en', 'eo', 'es', 'et', 'eu', 'fi', 'fr', 'fy', 'ga', 'gd', 'he', 'hi', 'hr', 'hu', 'hy', 'id', 'is', 'it', 'ja', 'ja_kana', 'ja_rm', 'ja-Latn', 'ja-Hira', 'ka', 'kk', 'kn', 'ko', 'ko-Latn', 'ku', 'la', 'lb', 'lt', 'lv', 'mk', 'mt', 'ml', 'mul', 'nl', 'no', 'oc', 'pl', 'pt', 'rm', 'ro', 'ru', 'sk', 'sl', 'sq', 'sr', 'sr-Latn', 'sv', 'ta', 'te', 'th', 'tr', 'uk', 'zh'];\n    return _this;\n  }\n\n  var _proto = OpenMapTilesLanguage.prototype;\n\n  _proto.isFlatExpressionField = function isFlatExpressionField(isLangField, property) {\n    var isGetExpression = property.length >= 2 && property[0] === 'get';\n\n    if (isGetExpression && typeof property[1] === 'string' && this.isTokenField.test(property[1])) {\n      console.warn('This plugin no longer supports the use of token syntax (e.g. {name}). Please use a get expression. See https://docs.mapbox.com/mapbox-gl-js/style-spec/expressions/ for more details.');\n    }\n\n    return isGetExpression && typeof property[1] === 'string' && isLangField.test(property[1]);\n  };\n\n  _proto.adaptNestedExpressionField = function adaptNestedExpressionField(isLangField, properties, languageFieldName) {\n    var _this2 = this;\n\n    properties.forEach(function (property) {\n      if (Array.isArray(property)) {\n        if (_this2.isFlatExpressionField(isLangField, property)) {\n          property[1] = languageFieldName;\n        }\n\n        _this2.adaptNestedExpressionField(isLangField, property, languageFieldName);\n      }\n    });\n  };\n\n  _proto.adaptPropertyLanguage = function adaptPropertyLanguage(isLangField, property, languageFieldName) {\n    if (this.isFlatExpressionField(isLangField, property)) {\n      property[1] = languageFieldName;\n    }\n\n    this.adaptNestedExpressionField(isLangField, property, languageFieldName); // handle special case of bare ['get', 'name'] expression by wrapping it in a coalesce statement\n\n    if (property[0] === 'get' && property[1] === 'name') {\n      var defaultProp = property.slice();\n      var adaptedProp = ['get', languageFieldName];\n      property = ['coalesce', adaptedProp, defaultProp];\n    }\n\n    return property;\n  };\n\n  _proto.splitLegacityFormat = function splitLegacityFormat(s) {\n    var ret = ['concat'];\n    var sub = '';\n\n    for (var i = 0; i < s.length; i++) {\n      if (s[i] === '{') {\n        if (sub) {\n          ret.push(sub);\n        }\n\n        sub = '';\n      } else if (s[i] === '}') {\n        if (sub) {\n          ret.push(['get', sub]);\n        }\n\n        sub = '';\n      } else {\n        sub += s[i];\n      }\n    }\n\n    if (sub) {\n      ret.push(sub);\n    }\n\n    return ret;\n  };\n\n  _proto.adaptLegacyExpression = function adaptLegacyExpression(expressions, languageFieldName) {\n    var _this3 = this;\n\n    // Kepp only first get name express\n    var isName = false;\n    var ret = [];\n    expressions.forEach(function (expression) {\n      // ['get', 'name:.*']\n      if (Array.isArray(expression) && expression.length >= 2 && typeof expression[1] === 'string' && _this3._isLanguageField.test(expression[1])) {\n        if (!isName) {\n          isName = true;\n          ret.push(['coalesce', ['get', languageFieldName], expression]);\n        }\n      } else {\n        ret.push(expression);\n      }\n    });\n    return ret;\n  };\n\n  _proto.adaptPropertyLanguageWithLegacySupport = function adaptPropertyLanguageWithLegacySupport(isLangField, property, languageFieldName) {\n    if (property.length === 4 && property[0] === 'coalesce' && typeof property[3] === 'string' && this.isTokenField.test(property[3])) {\n      // Back to original format string for legacy\n      property = property[3];\n    }\n\n    if (typeof property === 'string') {\n      // Only support legacy format string at top level\n      if (languageFieldName !== 'name' && this.isTokenField.test(property)) {\n        var splitLegacity = this.splitLegacityFormat(property); // The last is not used, it is the original value to be restore\n\n        return ['coalesce', this.adaptLegacyExpression(splitLegacity, languageFieldName), splitLegacity, property];\n      } else {\n        return property;\n      }\n    } else {\n      return this.adaptPropertyLanguage(isLangField, property, languageFieldName);\n    }\n  };\n\n  _proto.changeLayerTextProperty = function changeLayerTextProperty(isLangField, layer, languageFieldName, excludedLayerIds) {\n    if (this._map && layer.layout && layer.layout['text-field'] && excludedLayerIds.indexOf(layer.id) === -1) {\n      this._map.setLayoutProperty(layer.id, 'text-field', this.adaptPropertyLanguageWithLegacySupport(isLangField, layer.layout['text-field'], languageFieldName));\n    }\n  }\n  /**\r\n   * Explicitly change the language for a style.\r\n   */\n  ;\n\n  _proto.setLanguage = function setLanguage(language) {\n    var _this$_map, _this$_map$getStyle, _this$_map$getStyle$l;\n\n    if (this.supportedLanguages.indexOf(language) < 0) throw new Error('Language ' + language + ' is not supported');\n\n    var field = this._getLanguageField(language);\n\n    var isLangField = this._isLanguageField;\n    var excludedLayerIds = this._excludedLayerIds;\n    var self = this;\n    (_this$_map = this._map) == null ? void 0 : (_this$_map$getStyle = _this$_map.getStyle()) == null ? void 0 : (_this$_map$getStyle$l = _this$_map$getStyle.layers) == null ? void 0 : _this$_map$getStyle$l.filter(function (layer) {\n      return layer.type === 'symbol';\n    }).forEach(function (layer) {\n      self.changeLayerTextProperty(isLangField, layer, field, excludedLayerIds);\n    });\n  };\n\n  _proto._initialUpdate = function _initialUpdate() {\n    var _this$_options, _this$_map2;\n\n    _Control.prototype._initialUpdate.call(this);\n\n    var language = ((_this$_options = this._options) == null ? void 0 : _this$_options.defaultLanguage) || this.browserLanguage(this.supportedLanguages); // We only update the style once\n\n    (_this$_map2 = this._map) == null ? void 0 : _this$_map2.off('styledata', this._initialUpdate);\n    this.setLanguage(language);\n  };\n\n  _proto.browserLanguage = function browserLanguage(supportedLanguages) {\n    // @ts-ignore\n    var userLanguage = navigator.userLanguage;\n    var language = navigator.languages ? navigator.languages[0] : navigator.language || userLanguage;\n    var parts = language.split('-');\n    var languageCode = language;\n\n    if (parts.length > 1) {\n      languageCode = parts[0];\n    }\n\n    if (supportedLanguages.indexOf(languageCode) > -1) {\n      return languageCode;\n    }\n\n    return null;\n  };\n\n  return OpenMapTilesLanguage;\n}(Control);\n\nexport { OpenMapTilesLanguage };\n//# sourceMappingURL=openmaptiles_gl_language.esm.js.map\n","var debounce = require('./debounce'),\n    isObject = require('./isObject');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\nmodule.exports = throttle;\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    var proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    var copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        Buffer.from(buf).copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (var i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nvar hexSliceLookupTable = (function () {\n  var alphabet = '0123456789abcdef'\n  var table = new Array(256)\n  for (var i = 0; i < 16; ++i) {\n    var i16 = i * 16\n    for (var j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","// ray-casting algorithm based on\n// https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html\n\nmodule.exports = function pointInPolygonNested (point, vs, start, end) {\n    var x = point[0], y = point[1];\n    var inside = false;\n    if (start === undefined) start = 0;\n    if (end === undefined) end = vs.length;\n    var len = end - start;\n    for (var i = 0, j = len - 1; i < len; j = i++) {\n        var xi = vs[i+start][0], yi = vs[i+start][1];\n        var xj = vs[j+start][0], yj = vs[j+start][1];\n        var intersect = ((yi > y) !== (yj > y))\n            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n        if (intersect) inside = !inside;\n    }\n    return inside;\n};\n","'use strict';\n\nvar RBush = require('rbush');\nvar Queue = require('tinyqueue');\nvar pointInPolygon = require('point-in-polygon');\nvar orient = require('robust-predicates/umd/orient2d.min.js').orient2d;\n\n// Fix for require issue in webpack https://github.com/mapbox/concaveman/issues/18\nif (Queue.default) {\n    Queue = Queue.default;\n}\n\nmodule.exports = concaveman;\nmodule.exports.default = concaveman;\n\nfunction concaveman(points, concavity, lengthThreshold) {\n    // a relative measure of concavity; higher value means simpler hull\n    concavity = Math.max(0, concavity === undefined ? 2 : concavity);\n\n    // when a segment goes below this length threshold, it won't be drilled down further\n    lengthThreshold = lengthThreshold || 0;\n\n    // start with a convex hull of the points\n    var hull = fastConvexHull(points);\n\n    // index the points with an R-tree\n    var tree = new RBush(16);\n    tree.toBBox = function (a) {\n        return {\n            minX: a[0],\n            minY: a[1],\n            maxX: a[0],\n            maxY: a[1]\n        };\n    };\n    tree.compareMinX = function (a, b) { return a[0] - b[0]; };\n    tree.compareMinY = function (a, b) { return a[1] - b[1]; };\n\n    tree.load(points);\n\n    // turn the convex hull into a linked list and populate the initial edge queue with the nodes\n    var queue = [];\n    for (var i = 0, last; i < hull.length; i++) {\n        var p = hull[i];\n        tree.remove(p);\n        last = insertNode(p, last);\n        queue.push(last);\n    }\n\n    // index the segments with an R-tree (for intersection checks)\n    var segTree = new RBush(16);\n    for (i = 0; i < queue.length; i++) segTree.insert(updateBBox(queue[i]));\n\n    var sqConcavity = concavity * concavity;\n    var sqLenThreshold = lengthThreshold * lengthThreshold;\n\n    // process edges one by one\n    while (queue.length) {\n        var node = queue.shift();\n        var a = node.p;\n        var b = node.next.p;\n\n        // skip the edge if it's already short enough\n        var sqLen = getSqDist(a, b);\n        if (sqLen < sqLenThreshold) continue;\n\n        var maxSqLen = sqLen / sqConcavity;\n\n        // find the best connection point for the current edge to flex inward to\n        p = findCandidate(tree, node.prev.p, a, b, node.next.next.p, maxSqLen, segTree);\n\n        // if we found a connection and it satisfies our concavity measure\n        if (p && Math.min(getSqDist(p, a), getSqDist(p, b)) <= maxSqLen) {\n            // connect the edge endpoints through this point and add 2 new edges to the queue\n            queue.push(node);\n            queue.push(insertNode(p, node));\n\n            // update point and segment indexes\n            tree.remove(p);\n            segTree.remove(node);\n            segTree.insert(updateBBox(node));\n            segTree.insert(updateBBox(node.next));\n        }\n    }\n\n    // convert the resulting hull linked list to an array of points\n    node = last;\n    var concave = [];\n    do {\n        concave.push(node.p);\n        node = node.next;\n    } while (node !== last);\n\n    concave.push(node.p);\n\n    return concave;\n}\n\nfunction findCandidate(tree, a, b, c, d, maxDist, segTree) {\n    var queue = new Queue([], compareDist);\n    var node = tree.data;\n\n    // search through the point R-tree with a depth-first search using a priority queue\n    // in the order of distance to the edge (b, c)\n    while (node) {\n        for (var i = 0; i < node.children.length; i++) {\n            var child = node.children[i];\n\n            var dist = node.leaf ? sqSegDist(child, b, c) : sqSegBoxDist(b, c, child);\n            if (dist > maxDist) continue; // skip the node if it's farther than we ever need\n\n            queue.push({\n                node: child,\n                dist: dist\n            });\n        }\n\n        while (queue.length && !queue.peek().node.children) {\n            var item = queue.pop();\n            var p = item.node;\n\n            // skip all points that are as close to adjacent edges (a,b) and (c,d),\n            // and points that would introduce self-intersections when connected\n            var d0 = sqSegDist(p, a, b);\n            var d1 = sqSegDist(p, c, d);\n            if (item.dist < d0 && item.dist < d1 &&\n                noIntersections(b, p, segTree) &&\n                noIntersections(c, p, segTree)) return p;\n        }\n\n        node = queue.pop();\n        if (node) node = node.node;\n    }\n\n    return null;\n}\n\nfunction compareDist(a, b) {\n    return a.dist - b.dist;\n}\n\n// square distance from a segment bounding box to the given one\nfunction sqSegBoxDist(a, b, bbox) {\n    if (inside(a, bbox) || inside(b, bbox)) return 0;\n    var d1 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.minY, bbox.maxX, bbox.minY);\n    if (d1 === 0) return 0;\n    var d2 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.minY, bbox.minX, bbox.maxY);\n    if (d2 === 0) return 0;\n    var d3 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.maxX, bbox.minY, bbox.maxX, bbox.maxY);\n    if (d3 === 0) return 0;\n    var d4 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.maxY, bbox.maxX, bbox.maxY);\n    if (d4 === 0) return 0;\n    return Math.min(d1, d2, d3, d4);\n}\n\nfunction inside(a, bbox) {\n    return a[0] >= bbox.minX &&\n           a[0] <= bbox.maxX &&\n           a[1] >= bbox.minY &&\n           a[1] <= bbox.maxY;\n}\n\n// check if the edge (a,b) doesn't intersect any other edges\nfunction noIntersections(a, b, segTree) {\n    var minX = Math.min(a[0], b[0]);\n    var minY = Math.min(a[1], b[1]);\n    var maxX = Math.max(a[0], b[0]);\n    var maxY = Math.max(a[1], b[1]);\n\n    var edges = segTree.search({minX: minX, minY: minY, maxX: maxX, maxY: maxY});\n    for (var i = 0; i < edges.length; i++) {\n        if (intersects(edges[i].p, edges[i].next.p, a, b)) return false;\n    }\n    return true;\n}\n\nfunction cross(p1, p2, p3) {\n    return orient(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);\n}\n\n// check if the edges (p1,q1) and (p2,q2) intersect\nfunction intersects(p1, q1, p2, q2) {\n    return p1 !== q2 && q1 !== p2 &&\n        cross(p1, q1, p2) > 0 !== cross(p1, q1, q2) > 0 &&\n        cross(p2, q2, p1) > 0 !== cross(p2, q2, q1) > 0;\n}\n\n// update the bounding box of a node's edge\nfunction updateBBox(node) {\n    var p1 = node.p;\n    var p2 = node.next.p;\n    node.minX = Math.min(p1[0], p2[0]);\n    node.minY = Math.min(p1[1], p2[1]);\n    node.maxX = Math.max(p1[0], p2[0]);\n    node.maxY = Math.max(p1[1], p2[1]);\n    return node;\n}\n\n// speed up convex hull by filtering out points inside quadrilateral formed by 4 extreme points\nfunction fastConvexHull(points) {\n    var left = points[0];\n    var top = points[0];\n    var right = points[0];\n    var bottom = points[0];\n\n    // find the leftmost, rightmost, topmost and bottommost points\n    for (var i = 0; i < points.length; i++) {\n        var p = points[i];\n        if (p[0] < left[0]) left = p;\n        if (p[0] > right[0]) right = p;\n        if (p[1] < top[1]) top = p;\n        if (p[1] > bottom[1]) bottom = p;\n    }\n\n    // filter out points that are inside the resulting quadrilateral\n    var cull = [left, top, right, bottom];\n    var filtered = cull.slice();\n    for (i = 0; i < points.length; i++) {\n        if (!pointInPolygon(points[i], cull)) filtered.push(points[i]);\n    }\n\n    // get convex hull around the filtered points\n    return convexHull(filtered);\n}\n\n// create a new node in a doubly linked list\nfunction insertNode(p, prev) {\n    var node = {\n        p: p,\n        prev: null,\n        next: null,\n        minX: 0,\n        minY: 0,\n        maxX: 0,\n        maxY: 0\n    };\n\n    if (!prev) {\n        node.prev = node;\n        node.next = node;\n\n    } else {\n        node.next = prev.next;\n        node.prev = prev;\n        prev.next.prev = node;\n        prev.next = node;\n    }\n    return node;\n}\n\n// square distance between 2 points\nfunction getSqDist(p1, p2) {\n\n    var dx = p1[0] - p2[0],\n        dy = p1[1] - p2[1];\n\n    return dx * dx + dy * dy;\n}\n\n// square distance from a point to a segment\nfunction sqSegDist(p, p1, p2) {\n\n    var x = p1[0],\n        y = p1[1],\n        dx = p2[0] - x,\n        dy = p2[1] - y;\n\n    if (dx !== 0 || dy !== 0) {\n\n        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n            x = p2[0];\n            y = p2[1];\n\n        } else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n\n    dx = p[0] - x;\n    dy = p[1] - y;\n\n    return dx * dx + dy * dy;\n}\n\n// segment to segment distance, ported from http://geomalgorithms.com/a07-_distance.html by Dan Sunday\nfunction sqSegSegDist(x0, y0, x1, y1, x2, y2, x3, y3) {\n    var ux = x1 - x0;\n    var uy = y1 - y0;\n    var vx = x3 - x2;\n    var vy = y3 - y2;\n    var wx = x0 - x2;\n    var wy = y0 - y2;\n    var a = ux * ux + uy * uy;\n    var b = ux * vx + uy * vy;\n    var c = vx * vx + vy * vy;\n    var d = ux * wx + uy * wy;\n    var e = vx * wx + vy * wy;\n    var D = a * c - b * b;\n\n    var sc, sN, tc, tN;\n    var sD = D;\n    var tD = D;\n\n    if (D === 0) {\n        sN = 0;\n        sD = 1;\n        tN = e;\n        tD = c;\n    } else {\n        sN = b * e - c * d;\n        tN = a * e - b * d;\n        if (sN < 0) {\n            sN = 0;\n            tN = e;\n            tD = c;\n        } else if (sN > sD) {\n            sN = sD;\n            tN = e + b;\n            tD = c;\n        }\n    }\n\n    if (tN < 0.0) {\n        tN = 0.0;\n        if (-d < 0.0) sN = 0.0;\n        else if (-d > a) sN = sD;\n        else {\n            sN = -d;\n            sD = a;\n        }\n    } else if (tN > tD) {\n        tN = tD;\n        if ((-d + b) < 0.0) sN = 0;\n        else if (-d + b > a) sN = sD;\n        else {\n            sN = -d + b;\n            sD = a;\n        }\n    }\n\n    sc = sN === 0 ? 0 : sN / sD;\n    tc = tN === 0 ? 0 : tN / tD;\n\n    var cx = (1 - sc) * x0 + sc * x1;\n    var cy = (1 - sc) * y0 + sc * y1;\n    var cx2 = (1 - tc) * x2 + tc * x3;\n    var cy2 = (1 - tc) * y2 + tc * y3;\n    var dx = cx2 - cx;\n    var dy = cy2 - cy;\n\n    return dx * dx + dy * dy;\n}\n\nfunction compareByX(a, b) {\n    return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];\n}\n\nfunction convexHull(points) {\n    points.sort(compareByX);\n\n    var lower = [];\n    for (var i = 0; i < points.length; i++) {\n        while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {\n            lower.pop();\n        }\n        lower.push(points[i]);\n    }\n\n    var upper = [];\n    for (var ii = points.length - 1; ii >= 0; ii--) {\n        while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[ii]) <= 0) {\n            upper.pop();\n        }\n        upper.push(points[ii]);\n    }\n\n    upper.pop();\n    lower.pop();\n    return lower.concat(upper);\n}\n"],"names":[],"sourceRoot":""}